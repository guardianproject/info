---
id: 12100
title: Improving trust and flexibility in interactions between Android apps
date: 2014-01-21T13:51:57-04:00
author: Hans-Christoph Steiner
layout: post
guid: https://guardianproject.info/?p=12100
permalink: /2014/01/21/improving-trust-and-flexibility-in-interactions-between-android-apps/
categories:
  - Research
tags:
  - activity
  - Android
  - informaCam
  - intent
  - mobile
  - obscuracam
  - securesmartcam
---
<div id="attachment_12240" style="width: 310px" class="wp-caption alignright">
  <a href="https://guardianproject.info/wp-content/uploads/2014/01/Android-Intents.png"><img aria-describedby="caption-attachment-12240" src="https://guardianproject.info/wp-content/uploads/2014/01/Android-Intents-300x61.png" alt="Activity1 sending an Intent that either Activity2 or Activity3 can handle." width="300" height="61" class="size-medium wp-image-12240" srcset="https://guardianproject.info/wp-content/uploads/2014/01/Android-Intents-300x61.png 300w, https://guardianproject.info/wp-content/uploads/2014/01/Android-Intents.png 600w" sizes="(max-width: 300px) 100vw, 300px" /></a>
  
  <p id="caption-attachment-12240" class="wp-caption-text">
    <code>Activity1</code> sending an <code>Intent</code> that either <code>Activity2</code> or <code>Activity3</code> can handle.
  </p>
</div>Android provides a flexible system of messaging between apps in the form of 

`<a href="https://developer.android.com/guide/components/intents-filters.html" target="_blank">Intent</a>`s. It also provides the framework for reusing large chunks of apps based on the `<a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank">Activity</a>` class. `Intent`s are the messages that make the requests, and `Activity`s are the basic chunk of functionality in an app, including its interface. This combination allows apps to reuse large chunks of functionality while keeping the user experience seamless and fluent. For example, an app can send an Intent to request a camera `Activity` to prompt the user to take a picture, and that process can feel integrated into the original app that made the request. Another common use of this paradigm is choosing account information from the contacts database (aka the _People_ app). When a user is composing an new email, they will want to select who the message gets sent to. Android provides both the contacts database, and a nice overlay screen for finding and selecting the person to send to. This combination is an `Activity` provided by Android. The message that the email program sends in order to trigger that `Activity` is an `Intent`.

As usual, one of the downsides of flexibility is increased security risk. This is compounded in the Android system by rules that will automatically export an Activity to receive Intents from any app, <a href="https://www.eecs.berkeley.edu/~emc/papers/spsm4027-kantola.pdf" title="Reducing Attack Surfaces for Intra-Application Communication in Android" target="_blank">when certain conditions are met</a>. If an `Activity` is exported for any app to call, <a href="https://www.eecs.berkeley.edu/~emc/papers/mobi168-chin.pdf" title="Analyzing Inter-Application Communication in Android" target="_blank">it is possible for apps to send malicious <code>Intent</code>s</a> to that `Activity`. Many `Intents` are meant to be public and others are exported as a side effect. Either way, at the very least, it is necessary to <a href="http://blog.palominolabs.com/2013/05/13/android-security/" title="Intent Spoofing on Android" target="_blank">sanitize the input</a> that an `Activity` receives. On the other side of the issue, if an app is trusting another app to provide a sensitive service for it, then malware can pose as the trusted app and receive sensitive data from the trusting app. <a href="http://dwaterson.com/2013/06/24/data-harvesting-by-malicious-android-apps/" target="_blank">An app does not need to request any permissions in order to set itself up as a receiver of <code>Intent</code>s</a>.

<div id="attachment_12117" style="width: 361px" class="wp-caption aligncenter">
  <a href="https://www.eecs.berkeley.edu/~emc/papers/spsm4027-kantola.pdf"><img aria-describedby="caption-attachment-12117" src="https://guardianproject.info/wp-content/uploads/2014/01/activity-service-hijacking.png" alt="Activity/Service hijacking: watch out for the little devil in the system" width="351" height="153" class="size-full wp-image-12117" srcset="https://guardianproject.info/wp-content/uploads/2014/01/activity-service-hijacking.png 351w, https://guardianproject.info/wp-content/uploads/2014/01/activity-service-hijacking-300x130.png 300w" sizes="(max-width: 351px) 100vw, 351px" /></a>
  
  <p id="caption-attachment-12117" class="wp-caption-text">
    Activity/Service hijacking: watch out for the little devil in the system
  </p>
</div>

Android, of course, does provide some added protections for cases like this. For very sensitive situations, an `Activity` can be setup to only receive `Intent`s from apps that meet certain criteria. <a href="https://www.isecpartners.com/media/11991/isec_securing_android_apps.pdf" target="_blank">Android permissions can restrict other apps</a> from sending `Intent`s to any given exported `Activity`. If a separate app wants to send an `Intent` to an `Activity` that has be set with a permission, then that app must include that permission in its manifest, thereby publishing that it is using that permission. This provides a good way publish an API for getting permission, but leaving it relatively open for other apps to use. Other kinds of controls can be based on two aspects of an app that the Android system enforces to remain the same: <a href="http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html" target="_blank">the package name and the signing key</a>. If either of those change, then Android considers it a different app altogether. The strictest control is handled by the “protection level”, which can be set to only allow either the system or apps signed by the same key to send `Intent`s to a given `Activity`. These security tools are useful in many situations, but leave lots of privacy-oriented use cases uncovered.

There are some situations that need more flexibility without opening things up entirely. The first simple example is provided by our app <a href="https://guardianproject.info/apps/pixelknot/" target="_blank">Pixelknot</a>: it needs to send pictures through services that will not mess up the hidden data in the images. It has a trusted list of apps it will send to, based on apps that have proven to pass the images through unchanged. When the user goes to share the image from Pixelknot to an cloud storage app, the user will be prompted to choose from a list of installed apps that match the whitelist in Pixelknot. We could have implemented a permission and asked lots of app providers to implement it, but it seems a mammoth task to get lots of large companies like Dropbox and Google to include our specific permission.

There are other situations that require even tighter restrictions that are available. The first example here comes from our OpenPGP app for Android. <a href="https://guardianproject.info/code/gnupg/" target="_blank">Gnu Privacy Guard (GPG)</a> provides cryptographic services to any app that requests it. When the app sends data to GPG to be encrypted, it needs to be sure that the data is actually going to GPG and not to some malware. For very sensitive situations, the Android-provided package name and signing key might not be enough to ensure that the correct app is receiving the unencrypted data. Many Android devices are still unpatched to protect against <a href="https://threatpost.com/second-android-master-key-attack-surfaces/101297" target="_blank">master key bugs</a>, and for people using Android in China, Iran, etc. where the Play Store is not allowed, they don’t get the exploit scanning provided by Google. Telecoms around the world have proved to be <a href="https://arstechnica.com/gadgets/2012/12/the-checkered-slow-history-of-android-handset-updates/" target="_blank">bad at updating the software</a> for the devices that they sell, <a href="https://arstechnica.com/security/2013/04/wireless-carriers-deceptive-and-unfair" target="_blank">leaving many security problems unfixed</a>. Alternative Android app stores are a very popular way to get apps. So far, the ones that we have seen provide minimal security and no malware scanning. <a href="http://www.telecoms.com/57581/china-crucial-to-android/" target="_blank">In China</a>, <a href="http://www.insidemobileapps.com/2011/09/02/china-chinese-smartphone-ios-android-market/" target="_blank">Android is very popular</a>, so this represents a lot of Android users.

Another potential use case revolves around a media reporting app that relies on other apps to provide images and video as part of regular reports. This could be something like a citizen journalist editing app or a human rights reporting app. The Guardian Project develops a handful of apps designed to create media in these situations: <a href="https://guardianproject.info/apps/obscuracam/" target="_blank">ObscuraCam</a>, InformaCam, and an new secure camera app in the works that we are contributing to. We want InformaCam to work as a provider of verifiable media to any app. It generates a package of data that includes a cryptographic signature so that its authenticity can be verified. That means that the apps that transport the InformaCam data do not need to be trusted in order to guarantee the integrity of the uploaded InformaCam data. Therefore it does not make sense in this case for InformaCam to grant itself permissions to access other apps’ secured `Activity`s. It would add to the maintenance load of the app without furthering the goals of the InformaCam project. Luckily there are other ways to address that need.

The inverse of this situation is not true. The reporting app that gathers media and sends it to trusted destinations has higher requirements for validating the data it receives via `Intent`s. If verifiable media is required, then this reporter app will want to only accept incoming media from InformaCam. Well-known human rights activists are often the target of custom malware designed to get information from their phones. For this example, a malware version of InformaCam could be designed to track all of the media that the user is sending to the human rights reporting app. To prevent this, the reporter app will want to only accept data from a list of trusted apps. When the user tries to feed media from the malware app to the reporting app, it would be rejected, alerting the user that something is amiss. If an reporting app wants to receive data only from InformaCam, it needs to have some checks setup to enforce that. The easiest way for the reporting app to implement those checks would be to add an Android permission to the receiving `Activity`. But that requires the sending app, in the example above that is InformaCam, to implement the reporting app’s permission. Using permissions works for tailored interactions. InformaCam aims to bring tighter secure to all relevant interactions, so we need a different approach. While InformaCam could include some specific permissions, the aim is to have a single method that supports all the desired interactions. Having a single method here means less code to audit, less complexity, and fewer places for security bugs.

We have started auditing the security of communication via `Intent`s, while also working on various ideas to address the issues laid out so far. This will include laying out best-practices and defining gaps in the Android architecture. We plan on building the techniques that we find useful into reusable libraries to make it easy for others to also have more flexible and trusted interactions. When are the standard checks not enough? If the user has a malware version of an app that exploits master key bugs, then the signature on the app will be valid. If a check is based only on a package name, malware could use any given package name. Android enforces that only one app can be installed with a given package name, but if there are multiple apps with the same package name, Android will not prevent you from installing the malware version.

<div id="attachment_12120" style="width: 160px" class="wp-caption alignleft">
  <a href="http://www.pregnancyandbaby.com/the-hatch-blog/articles/935057/classic-vanilla-tofu-ice-pops-for-babies-from-ice-pop-joy"><img aria-describedby="caption-attachment-12120" src="https://guardianproject.info/wp-content/uploads/2014/01/IcePopJoy-ClassicVanillaTofu-300x300.jpg" alt="TOFU/POP: delicious vegan treat and clever software interaction!" width="150" height="150" class="size-medium wp-image-12120" srcset="https://guardianproject.info/wp-content/uploads/2014/01/IcePopJoy-ClassicVanillaTofu-300x300.jpg 300w, https://guardianproject.info/wp-content/uploads/2014/01/IcePopJoy-ClassicVanillaTofu-150x150.jpg 150w, https://guardianproject.info/wp-content/uploads/2014/01/IcePopJoy-ClassicVanillaTofu.jpg 450w" sizes="(max-width: 150px) 100vw, 150px" /></a>
  
  <p id="caption-attachment-12120" class="wp-caption-text">
    TOFU/POP: delicious vegan treat and clever software interaction!
  </p>
</div>The strictest possible checks can be based on the hash of the whole APK, while tracking the signing key of a given APK is also often useful. These two data points are the most reliable ways to verify a given app. They can be tracked in two different ways: pinning and trust-on-first-use (TOFU/POP). Pinning means that a verified hash or signing key for the apps that need to be trusted is included in the app that must trust them. Then the trusting app can verify what it is sending or receiving 

`Intent`s from, the installed app is then compared to the pre-stored pinned value. This kind of pinning allows for checks like the `Signature` permission level but based on a key that the app developer can select and include in the app. The built-in `Signature` permissions are fixed on the signing key of the currently running app.

TOFU/POP means Trust-On-First-Use/Persistence Of Pseudonym. In this model, popularized by SSH, the user marks a given hash or signing key as trusted the first time they use the app, without extended checks about that apps validity. That mark then describes a “pseudonym” for that app, since there is no verification process, and that pseudonym is remembered for comparing in future interactions. One big advantage of TOFU/POP is that the user has control over which apps to trust, and that trust relationship is created at the moment the user takes an action to start using the app that needs to be trusted. That makes it much easier to manage than using Android permissions, which must be managed by the app’s developer. A disadvantage is that the initial trust is basically a guess, and that leaves open a method to get malware in there. The problem of installing good software, and avoiding malware, is outside of the scope of securing inter-app communication. Secure app installation is best handled by the process that is actually installing the software, like the Google Play Store or <a href="https://f-droid.org" target="_blank">F-Droid</a> does.

To build on the InformaCam example, in order to setup a trusted data flow between InformaCam and the reporting app, custom checks must be implemented on both the sender and the receiver. For the sender, InformaCam, it should be able to send to any app, but it should then remember the app that it is configured to send to and make sure its really only sending to that app. It would then use TOFU/POP with the hash as the data point. For the receiver, the reporting app, it should only accept incoming data from apps that it trusts. The receiver then includes a pin for the signing key, or if the app is being deployed to unupdated devices the pin can be based on the hash to work around master key exploits. From there on out, the receiving app checks against the stored app hashes or signing keys. For less security-sensitive situations, the received can rely on TOFU/POP on the first time that an app sends media.

There are various versions of these ideas floating around in various apps, and we have some in the works. We are working now to hammer out which of these ideas are the most useful, then we will be focusing our development efforts there. We would love to hear about any related effort or libraries that are out there. And we are also interested to hear about entirely different approaches than what has been outlined here.