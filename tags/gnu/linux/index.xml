<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gnu/Linux on Guardian Project</title>
    <link>https://guardianproject.github.io/info/tags/gnu/linux/</link>
    <description>Recent content in Gnu/Linux on Guardian Project</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 30 Apr 2015 11:13:26 -0400</lastBuildDate>
    
        <atom:link href="https://guardianproject.github.io/info/tags/gnu/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Getting Android tools into Debian</title>
      <link>https://guardianproject.github.io/info/2015/04/30/getting-android-tools-into-debian/</link>
      <pubDate>Thu, 30 Apr 2015 11:13:26 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2015/04/30/getting-android-tools-into-debian/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2015/04/debian.jpg&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2015/04/debian-150x150.jpg&#34; alt=&#34;debian&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignright size-thumbnail wp-image-12920&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2015/04/debian-150x150.jpg 150w, https://guardianproject.info/wp-content/uploads/2015/04/debian-300x300.jpg 300w, https://guardianproject.info/wp-content/uploads/2015/04/debian-270x270.jpg 270w, https://guardianproject.info/wp-content/uploads/2015/04/debian-230x230.jpg 230w, https://guardianproject.info/wp-content/uploads/2015/04/debian.jpg 600w&#34; sizes=&#34;(max-width: 150px) 100vw, 150px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2015/04/android.png&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2015/04/android-150x150.png&#34; alt=&#34;android&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignright size-thumbnail wp-image-12919&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2015/04/android-150x150.png 150w, https://guardianproject.info/wp-content/uploads/2015/04/android-270x270.png 270w, https://guardianproject.info/wp-content/uploads/2015/04/android-230x230.png 230w&#34; sizes=&#34;(max-width: 150px) 100vw, 150px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As part of Debian’s project in Google &lt;a href=&#34;https://wiki.debian.org/SummerOfCode2015&#34; target=&#34;_blank&#34;&gt;Summer of Code&lt;/a&gt;, I’ll be working with two students, Kai-Chung Yan and Komal Sukhani, and another mentor from the &lt;a href=&#34;https://wiki.debian.org/Teams/JavaPackaging&#34; target=&#34;_blank&#34;&gt;Debian Java Team&lt;/a&gt; team, &lt;a href=&#34;https://&amp;#x71;a&amp;#x2e;d&amp;#x65;b&amp;#x69;a&amp;#x6e;.&amp;#x6f;r&amp;#x67;/dev&amp;#x65;l&amp;#x6f;p&amp;#x65;r&amp;#x2e;p&amp;#x68;p&amp;#x3f;l&amp;#x6f;gin=&amp;#x61;p&amp;#x6f;@&amp;#x67;a&amp;#x6d;b&amp;#x61;r&amp;#x75;.&amp;#x64;e&#34; target=&#34;_blank&#34;&gt;Markus Koschany&lt;/a&gt;. We are going to be working on getting the Android SDK and tools into Debian, as part of the Debian &lt;a href=&#34;https://wiki.debian.org/AndroidTools&#34; target=&#34;_blank&#34;&gt;Android Tools&lt;/a&gt; team, building upon the existing work already included from the Java and &lt;a href=&#34;https://wiki.debian.org/Teams/AndroidTools&#34; target=&#34;_blank&#34;&gt;Android Tools&lt;/a&gt; teams. This project is in conjunction with the Java team since there is overlap between Android and Java tools, like &lt;code&gt;gradle&lt;/code&gt;, &lt;code&gt;maven&lt;/code&gt;, etc. Since this work is in Debian, all of the Debian-derivatives will automatically inherit this work. That includes: Ubuntu, Mint, Elementary, and many more.&lt;/p&gt;

&lt;p&gt;The first question a lot of Android developers are probably asking is: why would we want to put the Android tools into Debian when there is already an official distribution from Google with it’s own update tools? It turns out there are many reasons, mostly centered around making things much easier to use, as well as addressing some key security concerns. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;automatic trustworthy downloads, no need to verify hash sums or think about HTTPS&lt;/li&gt;
&lt;li&gt;eliminate need for insecure wrapper scripts, like &lt;code&gt;./gradlew&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;easy install and update channel that all Debian users already know&lt;/li&gt;
&lt;li&gt;trivial install for specific tools, like &lt;code&gt;adb&lt;/code&gt;, &lt;code&gt;fastboot&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;setting up a Debian/Ubuntu/etc box for Android development is easier when everything is included&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2015/02/320px-Trawling_Drawing.jpg&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2015/02/320px-Trawling_Drawing-150x150.jpg&#34; alt=&#34;320px-Trawling_Drawing&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignright size-thumbnail wp-image-12873&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2015/02/320px-Trawling_Drawing-150x150.jpg 150w, https://guardianproject.info/wp-content/uploads/2015/02/320px-Trawling_Drawing-230x230.jpg 230w&#34; sizes=&#34;(max-width: 150px) 100vw, 150px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The most glaring issue from my point of view is the security issues in &lt;code&gt;gradle&lt;/code&gt;. It will happily download and execute code without any kind of verification whatsoever. It inherits this terrible practice from maven, which has been shown to be an &lt;a href=&#34;http://blog.ontoillogical.com/blog/2014/07/28/how-to-take-over-any-java-developer/&#34; target=&#34;_blank&#34;&gt;easy path to exploit anyone using it&lt;/a&gt;. This is especially concerning considering that developers are more and more &lt;a href=&#34;https://guardianproject.info/2015/02/24/phishing-for-developers/&#34; target=&#34;_blank&#34;&gt;being directly targeted&lt;/a&gt;. At least it is more common for &lt;code&gt;gradle&lt;/code&gt; configs to use HTTPS, but it is still quite easy mess up a config and force users to use HTTP instead. Fragile configs are really bad for security. Even if &lt;a href=&#34;https://github.com/WhisperSystems/gradle-witness&#34; target=&#34;_blank&#34;&gt;gradle-witness&lt;/a&gt; is used to pin the hash for the jars used in the project, &lt;code&gt;gradle-wrapper&lt;/code&gt; might still downloading insecure code an executing it immediately, giving attackers potential full user access to that machine. That is because &lt;code&gt;gradle-wrapper&lt;/code&gt; will download versions of &lt;code&gt;gradle&lt;/code&gt; that it needs, and &lt;code&gt;gradle-witness&lt;/code&gt; can not be used to pin the hash of the &lt;code&gt;gradle&lt;/code&gt; files. And the repositories that &lt;code&gt;gradle&lt;/code&gt; uses only provide methods to protect against network-based attacks. If the server that holds the jars is exploited, the attacker can replace the jars and the sum files at the same time. There is &lt;a href=&#34;https://github.com/gradle/gradle/pull/448&#34; target=&#34;_blank&#34;&gt;a pull request open for &lt;code&gt;gradle&lt;/code&gt;&lt;/a&gt; to allow pinning of the &lt;code&gt;gradle&lt;/code&gt; executables themselves, which will help this situation.&lt;/p&gt;

&lt;p&gt;On a different note, many people who are not developers at all want to use tools like &lt;code&gt;adb&lt;/code&gt; and &lt;code&gt;fastboot&lt;/code&gt; to access their Android device, or even root it. Having them in Debian means they are trivial for people to install, vastly easier than trying to figure out how to download and install the Android SDK. What lots of people end up doing instead is downloading random binaries from insecure internet forums and using those. For many devices, it is already possible to use only tools in Debian to root the device. As we get more of the Android tools packaged and updated in Debian, that will become the norm.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updates when you need them, built upon a stable base&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One common complaint about packages in Debian is that they are old and outdated. It is part of the core mission of Debian/stable to provide an operating system that changes as little as possible. That mission is contrary to what most developers need from their SDKs and sometimes even the development tools. But stability is also important for developers as well. For example, tools like &lt;code&gt;make&lt;/code&gt;, used to build native code using the Android NDK (&lt;code&gt;ndk-build&lt;/code&gt; is a &lt;code&gt;make&lt;/code&gt; script) and even Android itself, has been around a long time and is used in so many projects. That is a tool that almost every developer wants to have very stable.&lt;/p&gt;

&lt;p&gt;For the packages that developers need to have completely up-to-date, like the Android SDK itself, there are many options for distribution. Ubuntu Personal Package Archives (PPA) have proven easy and useful for exactly this kind of thing, and Debian is working on adding support for PPAs. Official repositories for &lt;a href=&#34;http://backports.debian.org/&#34; target=&#34;_blank&#34;&gt;backports&lt;/a&gt; are another avenue for timely updates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Help us figure this out&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We want lots of feedback on how to do this right! A great example is how to best support the various versions of &lt;code&gt;gradle&lt;/code&gt;. It seems to me that &lt;code&gt;gradle&lt;/code&gt; is starting to stabilize, and it is no longer necessary to track very specific releases of &lt;code&gt;gradle&lt;/code&gt;. For example, &lt;code&gt;gradle&lt;/code&gt; v2.2.1 will work well with projects that were setup with just about any v2.x version. And projects still using 1.x, they mostly seem to work using v1.12. So if this is the case, then this fits into a common pattern with build tools in Debian:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GNU Compiler Collection is packaged as &lt;code&gt;gcc4.8&lt;/code&gt;, &lt;code&gt;gcc4.7&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;Apache Maven is packaged as &lt;code&gt;maven&lt;/code&gt; and &lt;code&gt;maven2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GNU automake is packaged as &lt;code&gt;automake1.14&lt;/code&gt;, &lt;code&gt;automake1.13&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m currently thinking that the best solution for gradle is like Maven, with the package called &lt;code&gt;gradle&lt;/code&gt; (v2.3) being the most up-to-date in conjunction with specific packages to support older versions, like &lt;code&gt;gradle1&lt;/code&gt; (v1.12). But maybe it makes sense to do something like gcc, with a gcc meta-package to install the currently best supported version, then all versions packaged with name that includes that version, i.e. a gradle meta-package with &lt;code&gt;gradle1&lt;/code&gt;, &lt;code&gt;gradle2&lt;/code&gt;, &lt;code&gt;gradle3&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Other issues that we will have to grapple with include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how to package various NDK versions?&lt;/li&gt;
&lt;li&gt;How do we best work with the upstream Android team?&lt;/li&gt;
&lt;li&gt;is packaging Android Studio feasible?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also hope to provide an example that any other packaging systems can learn from and build upon. GNU/Linux distros like Arch and Fedora are the obvious ones, but also projects like Homebrew, MacPorts, and Cygwin could also use this work to include Android tools as packages in their system. Indeed, some of the work already included in Debian was derived from &lt;a href=&#34;https://wiki.archlinux.org/index.php/Android#Android_SDK_core_components&#34; target=&#34;_blank&#34;&gt;some Arch packages&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reducing metadata leakage from software updates</title>
      <link>https://guardianproject.github.io/info/2014/10/16/reducing-metadata-leakage-from-software-updates/</link>
      <pubDate>Thu, 16 Oct 2014 12:48:04 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2014/10/16/reducing-metadata-leakage-from-software-updates/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: now you can &lt;a href=&#34;https://guardianproject.info/2016/07/31/howto-get-all-your-debian-packages-via-tor-onion-services/&#34;&gt;do this with Tor Onion Services&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2014/10/leakage.png&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2014/10/leakage-300x199.png&#34; alt=&#34;leakage&#34; width=&#34;300&#34; height=&#34;199&#34; class=&#34;alignright size-medium wp-image-12699&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2014/10/leakage-300x199.png 300w, https://guardianproject.info/wp-content/uploads/2014/10/leakage-100x66.png 100w, https://guardianproject.info/wp-content/uploads/2014/10/leakage-150x99.png 150w, https://guardianproject.info/wp-content/uploads/2014/10/leakage-200x132.png 200w, https://guardianproject.info/wp-content/uploads/2014/10/leakage.png 410w&#34; sizes=&#34;(max-width: 300px) 100vw, 300px&#34; /&gt;&lt;/a&gt;Many software update systems use code signing to ensure that only the correct software is downloaded and installed, and to prevent the code from being altered. This is an effective way to prevent the code from being modified, and because of that, software update systems often use plain, unencrypted HTTP connections for downloading code updates. That means that the metadata of what packages a machine has installed is available in plain text for any network observer, from someone sitting on the same public WiFi as you, to state actors with full network observation capabilities.&lt;/p&gt;

&lt;p&gt;That means that potentially private information is leaking. That private information could be which packages you have installed and which versions. That information can help an attacker figure out the best way to break into the target machine. Also, a unique fingerprint can be generated based on which packages a machine has installed, and that could help de-anonymize traffic that goes over Tor or other anonymity tool.&lt;/p&gt;

&lt;p&gt;For people who use &lt;code&gt;apt-get&lt;/code&gt; in Debian, Ubuntu or any related GNU/Linux distro, there is a lot of metadata leaked to the internet when &lt;code&gt;apt-get&lt;/code&gt; contacts Debian repositories using a standard configuration. Mostly, that is because by default, the connections are unencrypted (http, ftp, rsync). The integrity of the package itself is not reason enough to use HTTPS since the GPG signing is much more reliable for that task. Here is how I break it down:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;package authenticity&lt;br /&gt;
(&lt;em&gt;software can be modified while being downloaded&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;repo availability&lt;br /&gt;
( &lt;em&gt;whole sites or specific URL paths can be selectively blocked by governments and companies&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;package availability&lt;br /&gt;
(&lt;em&gt;software security updates can be individually blocked&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;who’s downloading what package (&lt;em&gt;currently visible to anyone who can see the&lt;br /&gt;
network traffic, including open wifi, etc.&lt;/em&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The current apt model covers #1 well, but only covers #2 and #3 with a two week window (the expiration date on the repo metadata). And it does not cover #4 at all. Using HTTPS for apt repos is a simple way to improve the security of all 4. It adds a weak backup security layer for #1, it makes it much more difficult for a portion of a large internet mirror to be seletively blocked (e.g. #2 and #3). For example, if you use HTTPS to mirrors.kernel.org, everything has to be blocked to block Debian repos or packages. And pipelining downloads through a reused HTTPS connection makes it very difficult for the network observer to track metadata about packages, #4).&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2014/10/leakage-control.jpg&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2014/10/leakage-control-150x150.jpg&#34; alt=&#34;leakage control&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignright size-thumbnail wp-image-12701&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2014/10/leakage-control-150x150.jpg 150w, https://guardianproject.info/wp-content/uploads/2014/10/leakage-control-100x100.jpg 100w, https://guardianproject.info/wp-content/uploads/2014/10/leakage-control-200x200.jpg 200w, https://guardianproject.info/wp-content/uploads/2014/10/leakage-control.jpg 300w&#34; sizes=&#34;(max-width: 150px) 100vw, 150px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Luckily, there are some relatively easy steps that greatly reduce the amount of metadata that is leaked: using HTTPS connections to the mirrors and running those connections through Tor. Setting &lt;code&gt;apt-get&lt;/code&gt; to pipeline as many transactions into a given HTTPS session is also useful, but currently only supported for HTTP and not HTTPS. Even though HTTPS/TLS has security weaknesses, it is a lot better than nothing, and can help provide real world protection. The downside is that it is not common for Debian machines to connect to apt mirrors using HTTPS, so that potentially marks the install as a machine worth targeting. There are more and more HTTPS mirrors, and more interest in using them, so I think in time, that will only lessen as a concern. Here are the HTTPS mirrors that I have had good luck with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mirrors.ece.ubc.ca&lt;/li&gt;
&lt;li&gt;mirrors.kernel.org&lt;/li&gt;
&lt;li&gt;mirror.cse.unsw.edu.au&lt;/li&gt;
&lt;li&gt;spout.ussg.indiana.edu&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On that note, here is the config that I have been using on a number of Debian-deriv machines, and it has been working well. It requires &lt;code&gt;apt-transport-https&lt;/code&gt;, and &lt;a href=&#34;http://ubuntuguide.org/wiki/Tor#Privoxy&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;privoxy&lt;/code&gt; setup as an HTTP proxy for Tor&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;$ cat /etc/apt/apt.conf.d/99force-tor
# force everything through privoxy HTTP proxy to tor
Acquire::ftp::Proxy &#34;http://127.0.0.1:8118&#34;;
Acquire::http::Proxy &#34;http://127.0.0.1:8118&#34;;
Acquire::https::Proxy &#34;http://127.0.0.1:8118&#34;;

# don&#39;t use SSL, its insecure, only use TLS
Acquire::https::SslForceVersion &#34;TLSv1&#34;;
&lt;/pre&gt;

&lt;p&gt;I have found about 10 official Debian mirrors that have reliable HTTPS. Then I have a &lt;a href=&#34;https://gist.github.com/eighthave/7285154&#34; target=&#34;_blank&#34;&gt;script that finds all of them&lt;/a&gt;, but many have self-signed certs and other issues. A number of the HTTPS mirrors also mirror the “security” archive, but I recommend that the &lt;code&gt;http&lt;/code&gt; URL to the official &lt;code&gt;security.debian.org&lt;/code&gt; repo is still included to make sure that security updates are promptly available.&lt;/p&gt;

&lt;p&gt;I also have a test security repo running that is only available via an .onion address. I hope to encourage people to run official mirrors on a Tor Hidden Service, then HTTPS is not needed. Note that &lt;code&gt;apt-transport-tor&lt;/code&gt; is not required if a tor proxy is setup. To try mine, add it to your &lt;code&gt;sources.list&lt;/code&gt; (and make sure &lt;code&gt;apt-get&lt;/code&gt; is somehow using Tor). The order is important, that determines the priority of where &lt;code&gt;apt-get&lt;/code&gt; will get the package from is all other variables are the same.&lt;/p&gt;

&lt;pre&gt;deb http://dju2peblv7upfz3q.onion/debian-security/ wheezy/updates main
deb http://security.debian.org/ wheezy/updates main
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: Use the official &lt;a href=&#34;https://onion.debian.org/&#34; target=&#34;_blank&#34;&gt;Debian Tor Onion Services&lt;/a&gt; now, &lt;tt&gt;dju2peblv7upfz3q.onion&lt;/tt&gt; is deprecated and will be shut down!&lt;/p&gt;

&lt;h3 id=&#34;a-specific-example-tails&#34;&gt;A specific example: TAILS&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://tails.boum.org/&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2014/10/Tails-150x150.png&#34; alt=&#34;Tails&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignleft size-thumbnail wp-image-12711&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2014/10/Tails-150x150.png 150w, https://guardianproject.info/wp-content/uploads/2014/10/Tails-100x100.png 100w, https://guardianproject.info/wp-content/uploads/2014/10/Tails-200x200.png 200w, https://guardianproject.info/wp-content/uploads/2014/10/Tails.png 256w&#34; sizes=&#34;(max-width: 150px) 100vw, 150px&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;https://tails.boum.org/&#34; target=&#34;_blank&#34;&gt;TAILS&lt;/a&gt; is an operating system that aims to be as private and anonymous as possible to enable, and has allowed &lt;a href=&#34;https://freedom.press/blog/2014/04/help-support-little-known-privacy-tool-has-been-critical-journalists-reporting-nsa&#34; target=&#34;_blank&#34;&gt;journalists&lt;/a&gt; like &lt;a href=&#34;https://www.wired.com/2014/10/laura-poitras-crypto-tools-made-snowden-film-possible/&#34; target=&#34;_blank&#34;&gt;Laura Poitras&lt;/a&gt; to work without leaking information despite being targeted by some very skilled and highly resourced organizations. TAILS mostly works as a “live CD”, meaning the whole operating system is downloaded as a single “image” file, then either burned to a CD/DVD, or to a USB thumb drive. Updates work the same way. But TAILS has an optional feature to use the Debian package system to install and persist packages that are not included by default. TAILS does not use the default set of mirrors that a standard Debian install uses, it is set up by default with a range of possible Debian package sources, including the current stable version (called wheezy), the versions in testing, and packages backported to the stable version. That means that when this feature is used, TAILS fetches the metadata for all of those sections of Debian (stable/wheezy, testing, wheezy-backports, unstable).&lt;/p&gt;

&lt;p&gt;Given all of the proven fingerprinting approaches, like using the font list from the browser, I think its a safe assumption that the apt-get metadata will also provide similar fingerprinting opportunities. For basic TAILS use, this is all avoided since updates are done via ISO images. But once a user installs packages via &lt;code&gt;apt-get&lt;/code&gt;, that changes since TAILS then goes out onto the internet to fetch all of the repo metadata. That goes over Tor since TAILS forces all network traffic over Tor, so that helps break the link between the machine downloading the updates and those that can see that machines internet traffic.&lt;/p&gt;

&lt;p&gt;It seems quite likely that the set of mirrors and the order in which they are run will provide a way to identify the system as TAILS. As for identifying individual machines, &lt;code&gt;apt-get&lt;/code&gt; sends a lot of metadata, like language that the system is using, which packages need updates, etc. On top of the set of mirrors used, there is potentially enough metadata there to fingerprint the individual machine.&lt;/p&gt;

&lt;p&gt;One open question is how the &lt;code&gt;apt-get&lt;/code&gt; downloads map to different Tor circuits. If all of the traffic from a given &lt;code&gt;apt-get&lt;/code&gt; session goes over a single Tor circuit, then the exit node, the mirror server, and any network observer that can see the traffic between those two can use that as the fingerprint.&lt;/p&gt;

&lt;p&gt;To expand on this, if TAILS fetched all of its apt sources (wheezy, backports, testing, etc) via HTTPS from the same mirror (e.g. mirrors.kernel.org), then the exit node and network observer could not really distinguish the distro the machine making the connection was running since mirrors.kernel.org hosts many distro mirrors. There are two key parts here: using HTTPS to encrypt the data, and using HTTP pipelining so that network connections are reused for multiple downloads, rather than the default behavior of making a new HTTPS for each individual download. This setup would also prevent the custom pattern of apt sources from being distinguished since it would just show as downloading some series of files, and those files could be packages, package metadata, perl modules, source tarballs, etc.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
