<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Guardian Project</title>
    <link>https://guardianproject.github.io/info/tags/python/</link>
    <description>Recent content in Python on Guardian Project</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 10 Jan 2025 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://guardianproject.github.io/info/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using TLS ECH from Python</title>
      <link>https://guardianproject.github.io/info/2025/01/10/using-tls-ech-from-python/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2025/01/10/using-tls-ech-from-python/</guid>
      <description>&lt;p&gt;At first, the idea of encrypting more of the metadata found inside the initial packet (the &amp;ldquo;ClientHello&amp;rdquo;) of a TLS
connection may seem simple and obvious, but there are of course reasons that this wasn&amp;rsquo;t done right from the start.
In this post I will describe the flow of a connection using Encrypted Client Hello (ECH) to protect the metadata fields,
and present a working code example using a fork of CPython built with DEfO project&amp;rsquo;s OpenSSL fork to connect to
ECH-enabled HTTPS servers.&lt;/p&gt;

&lt;p&gt;To understand why this is an issue, let&amp;rsquo;s take a step back and look at how websites are hosted.
Many websites are hosted on shared servers, which means that a single server machine is responsible for serving
multiple, possibly hundreds or thousands, of websites.
This is known as the shared hosting model.
In this setup, when a user types in a URL or clicks on a link to visit a website and the browser connects to the server,
the server needs to know which website the users is requesting.
This is where the Server Name Indication (SNI) comes in - it&amp;rsquo;s a field in the initial packet of a TLS connection that
tells the server which website the user is trying to access.
The server can then send the correct certificate so that the browser can authenticate the connection, and then send the
requested website content.&lt;/p&gt;

&lt;p&gt;Because this field was sent unencrypted, this means that anyone who can see the traffic between the user&amp;rsquo;s browser and
the server can intercept the SNI and know which website the user is trying to visit.
This can be a privacy concern, as it allows ISPs, network administrators, or other unwanted observers to build a profile
of the user&amp;rsquo;s browsing history.
It&amp;rsquo;s not just about the websites they visit, but also about the potential for censorship or targeted attacks.
With the SNI being unencrypted, it&amp;rsquo;s like sending a postcard with the address visible to anyone who handles it - it may
not be the end of the world for most browsing activity, but it&amp;rsquo;s certainly not private.
Encrypted Client Hello aims to change this by encrypting the SNI and other metadata, making it much harder for third
parties to intercept and exploit this information.&lt;/p&gt;

&lt;p&gt;So, why wasn&amp;rsquo;t it easy to protect the SNI and other metadata from the start?
The main challenge was that, in order to encrypt the SNI, the client (i.e., the user&amp;rsquo;s browser) needs to know the
public key that the server wants the ClientHello to be encrypted with in advance.
However, the server&amp;rsquo;s ECH public key is tied to the specific website being requested, and there wasn&amp;rsquo;t a straightforward
way to discover a public key that could be used to talk to the server without revealing the SNI.
This created a chicken-and-egg problem, where the client couldn&amp;rsquo;t encrypt the SNI without knowing the server&amp;rsquo;s public
key, but it couldn&amp;rsquo;t know the server&amp;rsquo;s public key without sending the SNI in plaintext.&lt;/p&gt;

&lt;p&gt;This problem is solved with ECH by introducing a new type of DNS record, called an
&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9460&#34;&gt;HTTPS record&lt;/a&gt;.
An HTTPS record is a special type of DNS record that contains the ECH public key of the server, along with other metadata,
in a way that can be retrieved by the client without revealing the SNI (the website name is still leaked via the DNS
request, but it is possible to protect your requests using DNS-over-TLS or DNS-over-HTTPS).
The HTTPS record is typically retrieved by the client during the DNS lookup process, before the TLS connection is
established.&lt;/p&gt;

&lt;p&gt;The HTTPS record contains an ECH configuration, which is used to encrypt the SNI and other metadata.
This is generated by the server and is tied to the specific configuration of the server, rather than to a specific
website.
By using HTTPS records to retrieve the server&amp;rsquo;s ECH public key, we are able to break the chicken-and-egg problem and
provide a way to encrypt the SNI and other metadata.&lt;/p&gt;

&lt;p&gt;Before we can lookup the HTTPS record, it&amp;rsquo;s first necessary to work out where that record would live.
These records have been designed to be quite flexible, so can accommodate services running on non-default port numbers.
If the default port number is in use then the HTTPS record will be on the same domain name as the website, but for
non-default port numbers, there will be a prefix to the domain name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def svcbname(url: str) -&amp;gt; str:
    &amp;quot;&amp;quot;&amp;quot;Derive DNS name of SVCB/HTTPS record corresponding to target URL.&amp;quot;&amp;quot;&amp;quot;
    parsed = urllib.parse.urlparse(url)
    if parsed.scheme == &amp;quot;https&amp;quot;:
        if (parsed.port or 443) == 443:
            return parsed.hostname
        else:
            return f&amp;quot;_{parsed.port}._https.{parsed.hostname}&amp;quot;
    elif parsed.scheme == &amp;quot;http&amp;quot;:
        if (parsed.port or 80) in (443, 80):
            return parsed.hostname
        else:
            return f&amp;quot;_{parsed.port}._https.{parsed.hostname}&amp;quot;
    else:
        # For now, no other scheme is supported
        return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep it simple, the examples in this post will use plain DNS but the technique is equally applicable to DNS-over-TLS
and DNS-over-HTTPS. Now that we have the domain name to query, we can fetch the ECH configuration from the DNS using
the &lt;a href=&#34;https://www.dnspython.org/&#34;&gt;dnspython&lt;/a&gt; library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_ech_configs(domain) -&amp;gt; List[bytes]:
    try:
        answers = dns.resolver.resolve(domain, &amp;quot;HTTPS&amp;quot;)
    except dns.resolver.NoAnswer:
        logging.warning(f&amp;quot;No HTTPS record found for {domain}&amp;quot;)
        return []
    except Exception as e:
        logging.critical(f&amp;quot;DNS query failed: {e}&amp;quot;)
        sys.exit(1)
    configs: List[bytes] = []
    for rdata in answers:
        if hasattr(rdata, &amp;quot;params&amp;quot;):
            params = rdata.params
            echconfig = params.get(5)
            if echconfig:
                configs.append(echconfig.ech)
    if len(configs) == 0:
        logging.warning(f&amp;quot;No echconfig found in HTTPS record for {domain}&amp;quot;)
    return configs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the ECH configurations are known, these can be used to establish the connection and fetch the website:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_http(url, ech_configs) -&amp;gt; bytes:
    parser = urllib.parse.urlparse(url)
    hostname, port, path = url.hostname, url.port, url.path
    logging.debug(&amp;quot;Performing GET request for https://{hostname}:{port}/{path}&amp;quot;)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.load_verify_locations(certifi.where())
    for config in ech_configs:
        try:
            context.set_ech_config(config)
        except ssl.SSLError as e:
            logging.error(f&amp;quot;SSL error: {e}&amp;quot;)
            pass
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False) as ssock:
            try:
                ssock.do_handshake()
                logging.debug(&amp;quot;Handshake completed with ECH status: %s&amp;quot;, ssock.get_ech_status().name)
                logging.debug(&amp;quot;Inner SNI: %s, Outer SNI: %s&amp;quot;, ssock.server_hostname, ssock.outer_server_hostname)
                request = f&#39;GET {path} HTTP/1.1\r\nHost: {hostname}\r\nConnection: close\r\n\r\n&#39;
                ssock.sendall(request.encode(&#39;utf-8&#39;))
                response = b&#39;&#39;
                while True:
                    data = ssock.recv(4096)
                    if not data:
                        break
                    response += data
                return response
            except ssl.SSLError as e:
                logging.error(f&amp;quot;SSL error: {e}&amp;quot;)
                raise e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important step here is the new
&lt;a href=&#34;https://irl.github.io/cpython/library/ssl.html#ssl.SSLContext.set_ech_config&#34;&gt;&lt;code&gt;set_ech_config&lt;/code&gt;&lt;/a&gt; method on the
&lt;code&gt;SSLContext&lt;/code&gt; that allows you to add the ECH configuration containing the public key.
If there are multiple records, the underlying OpenSSL will determine which of the keys to use.
There are also a few new methods that allow you to get the status information relating to ECH from the &lt;code&gt;SSLSocket&lt;/code&gt;
after the completion of the handshake.&lt;/p&gt;

&lt;p&gt;In the simple case, that&amp;rsquo;s all there is to it.
If you were to watch the connection with Wireshark you would not be able to see the true SNI being sent to the server
and would only see the decoy SNI present in the unencrypted &amp;ldquo;ClientHelloOuter&amp;rdquo;.
This decoy SNI is added to appease &lt;a href=&#34;https://en.wikipedia.org/wiki/Middlebox&#34;&gt;middleboxes&lt;/a&gt; that may block traffic,
accidentally or deliberately, if that field is missing entirely.
There are also further protections against such middleboxes from the application of GREASE:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the client attempts to connect to a server and does not have an ECHConfig structure available for the server, it
SHOULD send a GREASE &amp;ldquo;encrypted_client_hello&amp;rdquo; extension in the first ClientHello [&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if your client supports ECH but does not have the configuration available to use it, the client should
still send an ECH extension filled with nonsense anyway.
This will help to detect deployment issues early as errors will be immediately obvious to users and won&amp;rsquo;t rely on
servers having deployed ECH before the errors are triggered.&lt;/p&gt;

&lt;p&gt;Finally, if the server sees this GREASE ECH extension then it can use this to know that you support ECH but didn&amp;rsquo;t
have a configuration available.
In its reply, it can send a &amp;ldquo;retry config&amp;rdquo; and then terminate the connection.
You then have the configuration available to start the connection again with a real ECH extension this time, and can
cache that for future requests too.&lt;/p&gt;

&lt;p&gt;For a full client example including the use of retry configs, you can see our
&lt;a href=&#34;https://github.com/defo-project/docker-defo-client/blob/main/pyclient.py&#34;&gt;example Python client&lt;/a&gt; at GitHub.
You&amp;rsquo;ll need to use this with our &lt;a href=&#34;https://github.com/irl/cpython&#34;&gt;CPython fork&lt;/a&gt; and
&lt;a href=&#34;https://github.com/defo-project/openssl&#34;&gt;OpenSSL fork&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Trusted Update Channels vs. Scratching Your Itch</title>
      <link>https://guardianproject.github.io/info/2019/12/02/trusted-update-channels-vs.-scratching-your-itch/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2019/12/02/trusted-update-channels-vs.-scratching-your-itch/</guid>
      <description>&lt;p&gt;One of the great things about free software is that people can easily take a functional program or library and customize it as they see fit.  Anyone can come along, submit bug fixes or improvements, and they can be easily shared across many people, projects, and organizations.  With distribution systems like Python&amp;rsquo;s &lt;a href=&#34;https://pypi.python.org&#34;&gt;pypi&lt;/a&gt;, there is an update channel that the trusted maintainers can publish fixes so consumers of the library can easily get updates.  When talking about update channels and code, it is unavoidable to also talk about people and trust.  One key piece is the trust relationship between the consumer and the maintainer.  The ideal software distribution system would be a blind, trustworthy pipe between the software maintainers and each end user.&lt;/p&gt;

&lt;p&gt;Since we are talking about libraries of code, the natural relationship turns out to be different than the trust relationship: it is between the consumer and the library itself, not the maintainers.  I use Requests for handling HTTP, not @nateprewitt&amp;rsquo;s fork.  My &lt;em&gt;setup.py&lt;/em&gt; includes a reference to &lt;code&gt;&#39;requests&#39;&lt;/code&gt;, not to the maintainers who I trust to keep the library updated.&lt;/p&gt;

&lt;p&gt;There have been cases were libraries were &lt;a href=&#34;https://www.zdnet.com/article/backdoor-code-found-in-11-ruby-libraries/&#34;&gt;taken&lt;/a&gt; &lt;a href=&#34;https://www.theregister.co.uk/2018/07/12/npm_eslint/&#34;&gt;over&lt;/a&gt; and used to distribute malware.  Or &lt;a href=&#34;https://www.theregister.co.uk/2018/11/26/npm_repo_bitcoin_stealer/&#34;&gt;another case&lt;/a&gt; where someone offered to take over a popular library, then inserted malware into it.  If it is really easy for maintainers to hand over a library to someone else, then that will be abused.  If they are too hard to hand over, then many valuable libraries will be abandoned or forked.  Having to check for forks is an added cost for library consumers, so ideally there would always be a trusted maintainer.&lt;/p&gt;

&lt;p&gt;For large projects like Requests or distros like Debian, there is a process for ensuring that new maintainers are doing the right thing.  There are also many small libraries that are very valuable.  For example, &lt;a href=&#34;https://github.com/rory/apache-log-parser&#34;&gt;apache_log_parser&lt;/a&gt; or &lt;a href=&#34;https://pypi.org/project/PyMTP/&#34;&gt;pymtp&lt;/a&gt;.   In these cases, the cost of doing a proper process of handing over to a new maintainer is quite large as compared to the overall effort the library author put into the library.  Or it might be a single maintainer who is now overburdened with other work.&lt;/p&gt;

&lt;p&gt;In F-Droid, reviewing app merge requests, aka &lt;em&gt;fdroiddata&lt;/em&gt;, is also about reviewing whether the trust relationship is changing.  This is on top of making sure the new code works, ensuring its still free software, and that all of the Anti-Features are properly marked.  Getting this review right is important especially when you consider that in F-Droid, many apps are automatically updated without core contributors reviewing it.&lt;/p&gt;

&lt;p&gt;All developers must consider these trust issues at a number of key points in the process of developing software, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;when adding a library to any piece of software&lt;/li&gt;
&lt;li&gt;helping a new maintainer take over existing software&lt;/li&gt;
&lt;li&gt;reviewing changes to the URL of the source code reposistory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are also some ideas about how to better map who we need to trust to the process of including software.  One interesting example is &lt;a href=&#34;https://dpc.pw/cargo-crev-and-rust-2019-fearless-code-reuse&#34;&gt;&lt;em&gt;cargo-crev&lt;/em&gt;&lt;/a&gt; for the Rust ecosystem.  It provides a system of describing and cryptographically linking trusted developers and their reviews of software packages.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
