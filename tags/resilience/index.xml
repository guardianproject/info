<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Resilience on Guardian Project</title>
    <link>https://guardianproject.github.io/info/tags/resilience/</link>
    <description>Recent content in Resilience on Guardian Project</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 10 Jan 2025 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://guardianproject.github.io/info/tags/resilience/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using TLS ECH from Python</title>
      <link>https://guardianproject.github.io/info/2025/01/10/using-tls-ech-from-python/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2025/01/10/using-tls-ech-from-python/</guid>
      <description>&lt;p&gt;At first, the idea of encrypting more of the metadata found inside the initial packet (the &amp;ldquo;ClientHello&amp;rdquo;) of a TLS
connection may seem simple and obvious, but there are of course reasons that this wasn&amp;rsquo;t done right from the start.
In this post I will describe the flow of a connection using Encrypted Client Hello (ECH) to protect the metadata fields,
and present a working code example using a fork of CPython built with DEfO project&amp;rsquo;s OpenSSL fork to connect to
ECH-enabled HTTPS servers.&lt;/p&gt;

&lt;p&gt;To understand why this is an issue, let&amp;rsquo;s take a step back and look at how websites are hosted.
Many websites are hosted on shared servers, which means that a single server machine is responsible for serving
multiple, possibly hundreds or thousands, of websites.
This is known as the shared hosting model.
In this setup, when a user types in a URL or clicks on a link to visit a website and the browser connects to the server,
the server needs to know which website the users is requesting.
This is where the Server Name Indication (SNI) comes in - it&amp;rsquo;s a field in the initial packet of a TLS connection that
tells the server which website the user is trying to access.
The server can then send the correct certificate so that the browser can authenticate the connection, and then send the
requested website content.&lt;/p&gt;

&lt;p&gt;Because this field was sent unencrypted, this means that anyone who can see the traffic between the user&amp;rsquo;s browser and
the server can intercept the SNI and know which website the user is trying to visit.
This can be a privacy concern, as it allows ISPs, network administrators, or other unwanted observers to build a profile
of the user&amp;rsquo;s browsing history.
It&amp;rsquo;s not just about the websites they visit, but also about the potential for censorship or targeted attacks.
With the SNI being unencrypted, it&amp;rsquo;s like sending a postcard with the address visible to anyone who handles it - it may
not be the end of the world for most browsing activity, but it&amp;rsquo;s certainly not private.
Encrypted Client Hello aims to change this by encrypting the SNI and other metadata, making it much harder for third
parties to intercept and exploit this information.&lt;/p&gt;

&lt;p&gt;So, why wasn&amp;rsquo;t it easy to protect the SNI and other metadata from the start?
The main challenge was that, in order to encrypt the SNI, the client (i.e., the user&amp;rsquo;s browser) needs to know the
public key that the server wants the ClientHello to be encrypted with in advance.
However, the server&amp;rsquo;s ECH public key is tied to the specific website being requested, and there wasn&amp;rsquo;t a straightforward
way to discover a public key that could be used to talk to the server without revealing the SNI.
This created a chicken-and-egg problem, where the client couldn&amp;rsquo;t encrypt the SNI without knowing the server&amp;rsquo;s public
key, but it couldn&amp;rsquo;t know the server&amp;rsquo;s public key without sending the SNI in plaintext.&lt;/p&gt;

&lt;p&gt;This problem is solved with ECH by introducing a new type of DNS record, called an
&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9460&#34;&gt;HTTPS record&lt;/a&gt;.
An HTTPS record is a special type of DNS record that contains the ECH public key of the server, along with other metadata,
in a way that can be retrieved by the client without revealing the SNI (the website name is still leaked via the DNS
request, but it is possible to protect your requests using DNS-over-TLS or DNS-over-HTTPS).
The HTTPS record is typically retrieved by the client during the DNS lookup process, before the TLS connection is
established.&lt;/p&gt;

&lt;p&gt;The HTTPS record contains an ECH configuration, which is used to encrypt the SNI and other metadata.
This is generated by the server and is tied to the specific configuration of the server, rather than to a specific
website.
By using HTTPS records to retrieve the server&amp;rsquo;s ECH public key, we are able to break the chicken-and-egg problem and
provide a way to encrypt the SNI and other metadata.&lt;/p&gt;

&lt;p&gt;Before we can lookup the HTTPS record, it&amp;rsquo;s first necessary to work out where that record would live.
These records have been designed to be quite flexible, so can accommodate services running on non-default port numbers.
If the default port number is in use then the HTTPS record will be on the same domain name as the website, but for
non-default port numbers, there will be a prefix to the domain name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def svcbname(url: str) -&amp;gt; str:
    &amp;quot;&amp;quot;&amp;quot;Derive DNS name of SVCB/HTTPS record corresponding to target URL.&amp;quot;&amp;quot;&amp;quot;
    parsed = urllib.parse.urlparse(url)
    if parsed.scheme == &amp;quot;https&amp;quot;:
        if (parsed.port or 443) == 443:
            return parsed.hostname
        else:
            return f&amp;quot;_{parsed.port}._https.{parsed.hostname}&amp;quot;
    elif parsed.scheme == &amp;quot;http&amp;quot;:
        if (parsed.port or 80) in (443, 80):
            return parsed.hostname
        else:
            return f&amp;quot;_{parsed.port}._https.{parsed.hostname}&amp;quot;
    else:
        # For now, no other scheme is supported
        return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep it simple, the examples in this post will use plain DNS but the technique is equally applicable to DNS-over-TLS
and DNS-over-HTTPS. Now that we have the domain name to query, we can fetch the ECH configuration from the DNS using
the &lt;a href=&#34;https://www.dnspython.org/&#34;&gt;dnspython&lt;/a&gt; library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_ech_configs(domain) -&amp;gt; List[bytes]:
    try:
        answers = dns.resolver.resolve(domain, &amp;quot;HTTPS&amp;quot;)
    except dns.resolver.NoAnswer:
        logging.warning(f&amp;quot;No HTTPS record found for {domain}&amp;quot;)
        return []
    except Exception as e:
        logging.critical(f&amp;quot;DNS query failed: {e}&amp;quot;)
        sys.exit(1)
    configs: List[bytes] = []
    for rdata in answers:
        if hasattr(rdata, &amp;quot;params&amp;quot;):
            params = rdata.params
            echconfig = params.get(5)
            if echconfig:
                configs.append(echconfig.ech)
    if len(configs) == 0:
        logging.warning(f&amp;quot;No echconfig found in HTTPS record for {domain}&amp;quot;)
    return configs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the ECH configurations are known, these can be used to establish the connection and fetch the website:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_http(url, ech_configs) -&amp;gt; bytes:
    parser = urllib.parse.urlparse(url)
    hostname, port, path = url.hostname, url.port, url.path
    logging.debug(&amp;quot;Performing GET request for https://{hostname}:{port}/{path}&amp;quot;)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.load_verify_locations(certifi.where())
    for config in ech_configs:
        try:
            context.set_ech_config(config)
        except ssl.SSLError as e:
            logging.error(f&amp;quot;SSL error: {e}&amp;quot;)
            pass
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False) as ssock:
            try:
                ssock.do_handshake()
                logging.debug(&amp;quot;Handshake completed with ECH status: %s&amp;quot;, ssock.get_ech_status().name)
                logging.debug(&amp;quot;Inner SNI: %s, Outer SNI: %s&amp;quot;, ssock.server_hostname, ssock.outer_server_hostname)
                request = f&#39;GET {path} HTTP/1.1\r\nHost: {hostname}\r\nConnection: close\r\n\r\n&#39;
                ssock.sendall(request.encode(&#39;utf-8&#39;))
                response = b&#39;&#39;
                while True:
                    data = ssock.recv(4096)
                    if not data:
                        break
                    response += data
                return response
            except ssl.SSLError as e:
                logging.error(f&amp;quot;SSL error: {e}&amp;quot;)
                raise e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important step here is the new
&lt;a href=&#34;https://irl.github.io/cpython/library/ssl.html#ssl.SSLContext.set_ech_config&#34;&gt;&lt;code&gt;set_ech_config&lt;/code&gt;&lt;/a&gt; method on the
&lt;code&gt;SSLContext&lt;/code&gt; that allows you to add the ECH configuration containing the public key.
If there are multiple records, the underlying OpenSSL will determine which of the keys to use.
There are also a few new methods that allow you to get the status information relating to ECH from the &lt;code&gt;SSLSocket&lt;/code&gt;
after the completion of the handshake.&lt;/p&gt;

&lt;p&gt;In the simple case, that&amp;rsquo;s all there is to it.
If you were to watch the connection with Wireshark you would not be able to see the true SNI being sent to the server
and would only see the decoy SNI present in the unencrypted &amp;ldquo;ClientHelloOuter&amp;rdquo;.
This decoy SNI is added to appease &lt;a href=&#34;https://en.wikipedia.org/wiki/Middlebox&#34;&gt;middleboxes&lt;/a&gt; that may block traffic,
accidentally or deliberately, if that field is missing entirely.
There are also further protections against such middleboxes from the application of GREASE:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the client attempts to connect to a server and does not have an ECHConfig structure available for the server, it
SHOULD send a GREASE &amp;ldquo;encrypted_client_hello&amp;rdquo; extension in the first ClientHello [&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if your client supports ECH but does not have the configuration available to use it, the client should
still send an ECH extension filled with nonsense anyway.
This will help to detect deployment issues early as errors will be immediately obvious to users and won&amp;rsquo;t rely on
servers having deployed ECH before the errors are triggered.&lt;/p&gt;

&lt;p&gt;Finally, if the server sees this GREASE ECH extension then it can use this to know that you support ECH but didn&amp;rsquo;t
have a configuration available.
In its reply, it can send a &amp;ldquo;retry config&amp;rdquo; and then terminate the connection.
You then have the configuration available to start the connection again with a real ECH extension this time, and can
cache that for future requests too.&lt;/p&gt;

&lt;p&gt;For a full client example including the use of retry configs, you can see our
&lt;a href=&#34;https://github.com/defo-project/docker-defo-client/blob/main/pyclient.py&#34;&gt;example Python client&lt;/a&gt; at GitHub.
You&amp;rsquo;ll need to use this with our &lt;a href=&#34;https://github.com/irl/cpython&#34;&gt;CPython fork&lt;/a&gt; and
&lt;a href=&#34;https://github.com/defo-project/openssl&#34;&gt;OpenSSL fork&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick set up guide for Encrypted Client Hello (ECH)</title>
      <link>https://guardianproject.github.io/info/2023/11/10/quick-set-up-guide-for-encrypted-client-hello-ech/</link>
      <pubDate>Fri, 10 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2023/11/10/quick-set-up-guide-for-encrypted-client-hello-ech/</guid>
      <description>

&lt;p&gt;The Encrypted Client Hello (ECH) mechanism &lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-esni&#34;&gt;draft-spec&lt;/a&gt; is a way to plug a few privacy-holes that remain in the Transport Layer Security (TLS) protocol that&amp;rsquo;s used as the security layer for the web. OpenSSL is a widely used library that provides an implementation of the TLS protocol. The &lt;a href=&#34;https://defo.ie/&#34;&gt;DEfO project&lt;/a&gt; has developed an implementation of ECH for OpenSSL, and proof-of-concept implementations of various clients and servers that use OpenSSL, and other TLS libraries, as a demonstration and for interoperability testing. DEfO is funded by the Open Technology Fund (OTF).&lt;/p&gt;

&lt;p&gt;This guide is aimed at those who would like to try out ECH with our experimental Debian &lt;em&gt;unstable&lt;/em&gt; packages for OpenSSL, &lt;em&gt;curl&lt;/em&gt; and &lt;em&gt;nginx&lt;/em&gt;. The DEfO project is making packages temporarily available so people can carry out such experiments before upstream maintainers include ECH in standard releases.&lt;/p&gt;

&lt;p&gt;This guide describes two set ups: one assumes that you want to setup everything (i.e. a web server and associated DNS authoritative server) on one virtual machine and a second describes a way to set up an ECH-enabled web server if you have an existing DNS configuration elsewhere. Many other configurations are of course possible. Comments/questions are welcome via &lt;a href=&#34;mailto:info@defo.ie&#34;&gt;email&lt;/a&gt; or as GitLab issues/merge requests.&lt;/p&gt;

&lt;p&gt;In summary this guide shows how to:
- find and install our Debian &lt;em&gt;unstable&lt;/em&gt; packages
- configure a minimal DNS setup (using dnsmasq or bind) that enables use of ECH from browsers
- configure a minimal &lt;em&gt;nginx&lt;/em&gt; setup for an ECH enabled web sites
- test your DNS set up and that ECH is working&lt;/p&gt;

&lt;p&gt;We assume the reader is comfortable with simple DNS management and system administration tasks.
When commands shown below should be run as &lt;code&gt;root&lt;/code&gt; they are prepended with a &amp;lsquo;#&amp;rsquo;, if not they are prepended with a &amp;lsquo;$&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;install-packages&#34;&gt;Install packages&lt;/h2&gt;

&lt;p&gt;You need to first have access to a virtual machine running Debian &lt;em&gt;unstable&lt;/em&gt;. Many online resources describe many ways to do this.&lt;/p&gt;

&lt;p&gt;We start with an empty (minimal) Debian &lt;em&gt;unstable&lt;/em&gt; system and install OpenSSL from the DEfO apt repository.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt install ca-certificates
# echo &amp;quot;deb [trusted=yes] https://defo.ie/debian/ ./&amp;quot; &amp;gt; /etc/apt/sources.list.d/defo.list
# apt update
# apt install openssl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pick-some-dns-names-to-use&#34;&gt;Pick some DNS names to use&lt;/h2&gt;

&lt;p&gt;In the text below we assume that the web server for which we wish to benefit from ECH is called &lt;code&gt;hidden.example.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ECH also involves a so-called &lt;code&gt;public_name&lt;/code&gt; - that&amp;rsquo;s present in the outer ClientHello when ECH is used and hence is visible to a network observer, unlike the server name we include inside the Encrypted Client Hello. The &lt;code&gt;public_name&lt;/code&gt; we use below is &lt;code&gt;example.com&lt;/code&gt;`&lt;/p&gt;

&lt;p&gt;You should obviously substitute your chosen DNS names.&lt;/p&gt;

&lt;h2 id=&#34;generate-an-ech-key-pair&#34;&gt;Generate an ECH key pair&lt;/h2&gt;

&lt;p&gt;For ECH to work, we need a new asymmetric key pair. (Different from those used for TLS server authentication), so next we generate an ECH key pair:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# mkdir /etc/echkeydir/
# openssl ech -public_name example.com -out /etc/echkeydir/example.pem.ech
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we need this file later to set up DNS as well as &lt;em&gt;nginx&lt;/em&gt;. &lt;em&gt;Nginx&lt;/em&gt; will make use of the private key from the ECH key file, whilst the DNS will be used to publish the corresponding public key in an HTTPS resource record (that&amp;rsquo;s where ECH-enabled browsers will look for ECH public keys).&lt;/p&gt;

&lt;p&gt;The file name chosen should end with &lt;code&gt;.pem.ech&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;set-up-dns&#34;&gt;Set up DNS&lt;/h2&gt;

&lt;p&gt;There are many ways in which one can set up the DNS records required to enable experimenting with ECH. We document two ways here, the first is where the main DNS name with which you&amp;rsquo;re experimenting is newly registered DNS name and has no existing DNS set up. The second describes a case where a DNS name exists but we need to add some new resource records to enable ECH.&lt;/p&gt;

&lt;p&gt;In both cases, &lt;code&gt;&amp;lt;IP&amp;gt;&lt;/code&gt; should be the IPv4 address for the host running the web server. (We leave IPv6 handling as an exercise for the reader, but there&amp;rsquo;s nothing ECH-specific required for IPv6.)&lt;/p&gt;

&lt;h3 id=&#34;standalone-new-setup-dnsmasq-as-a-authoritative-dns-server-to-serve-the-ech-key-on-the-same-vm&#34;&gt;Standalone/New setup : dnsmasq as a authoritative DNS server to serve the ECH key (on the same VM)&lt;/h3&gt;

&lt;p&gt;In this case we also need to pick some DNS nameserver names, we assume the authoritative primary nameserver for both web server DNS names is &lt;code&gt;ns.example.com&lt;/code&gt; with a secondary of &lt;code&gt;ns2.example.com&lt;/code&gt;`&lt;/p&gt;

&lt;p&gt;The DNS set up to use starting from a clean dnsmasq install:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt install dnsmasq
# cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/dnsmasq.d/example.conf
no-resolv
no-hosts
auth-server=ns.example.com,ns2.example.com
auth-zone=example.com
auth-sec-servers=ns2.example.com
auth-soa=42,admin.example.com
host-record=example.com,&amp;lt;IP&amp;gt;
host-record=hidden.example.com,&amp;lt;IP&amp;gt;
dns-rr=hidden.example.com,65,&amp;lt;ascii-hex encoded HTTPS rdata&amp;gt;
EOF
# systemctl restart dnsmasq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you need to bump the SOA version (42 in the above) every time you change the config and make sure the zone distributes to ns2.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;ascii-hex encoded HTTPS rdata&amp;gt;&lt;/code&gt; will be published as the HTTPS resource record (type == 65) for &lt;code&gt;hidden.example.com&lt;/code&gt; and can be produced from the file we generated earlier via a shell script you can download and use as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ _curl_ https://raw.githubusercontent.com/sftcd/openssl/ECH-draft-13c/esnistuff/pem2rr.sh -o pem2rr.sh
$ chmod u+x pem2rr.sh
$ ./pem2rr.sh /etc/echkeydir/example.pem.ech
0001000005003b0039fe0d0035db0020002059907d619054c907a1f296ceb63dde1d57f72f15db172601a2f6b55e66e7cd0f00040001000100066261722e69650000
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;existing-dns-name-setup-using-bind-to-publish-new-ech-related-resource-records&#34;&gt;Existing DNS name setup: using bind to publish new ECH related resource records&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s assume you have an existing bind-based DNS setup for &lt;code&gt;example.com&lt;/code&gt;&lt;code&gt;, but are moving the IP address for that to a new VM that&#39;ll run the ECH-enabled web server for both&lt;/code&gt;example.com&lt;code&gt;and&lt;/code&gt;hidden.example.com`&lt;code&gt;. The change you might then make using the bind&lt;/code&gt;nsupdate` command on the authoritative DNS server would then look like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Change/add IP address records for our DNS names.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bind&#34;&gt;$ sudo nsupdate -l
&amp;gt; update delete example.com a
&amp;gt; update delete example.com aaaa
&amp;gt; update add example.com 300 a &amp;lt;IP&amp;gt;
&amp;gt; update add hidden.example.com 300 a &amp;lt;IP&amp;gt;
&amp;gt; send
&amp;gt; quit
$
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Add new HTTPS resource record for &lt;code&gt;hidden.example.com&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First we need to get the base64 encoded public from our &lt;code&gt;/etc/echkeydir/example.pem.ech&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tail -2 /etc/echkeydir/example.pem.ech | head -1
ADr+DQA2mQAgACAF7cLT+KtK0oR2DrRCGXmzBWM1eHgJgDEGLqL644/OcAAEAAEAAQAHaG9iYS5pZQAA
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That base64 encoded value is what we need to publish in the DNS&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo nsupdate -l
&amp;gt; update delete hidden.example.com HTTPS
&amp;gt; update add hidden.example.com 300 HTTPS 1 . ech=&amp;lt;base64-encoded-value&amp;gt;
&amp;gt; send
&amp;gt; quit
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;checking-your-dns-set-up&#34;&gt;Checking your DNS set up&lt;/h2&gt;

&lt;p&gt;You can check that value is correctly published in the DNS e.g. using the &lt;code&gt;dig command&lt;/code&gt;`:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dig +short https hidden.example.com
1 . ech=ADr+DQA2mQAgACAF7cLT+KtK0oR2DrRCGXmzBWM1eHgJgDEGLqL644/OcAAEAAEAAQAHaG9iYS5pZQAA
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your version of &lt;code&gt;dig&lt;/code&gt; is older and doesn&amp;rsquo;t know about HTTPS resource records, then you may need to check via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dig +short +unknownformat -t TYPE65 hidden.example.com
\# 67 0001000005003C003AFE0D0036990020002005EDC2D3F8AB4AD28476 0EB4421979B30563357878098031062EA2FAE38FCE70000400010001 0007686F62612E69650000
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The 2nd-last invocation of &lt;code&gt;dig&lt;/code&gt; above shows the presentation format version of the HTTPS resource record. The last invocation above shows the equivalent in ascii-hex, which (minus the spaces) is what &lt;code&gt;dnsmasq&lt;/code&gt; needs in it&amp;rsquo;s configuration file.&lt;/p&gt;

&lt;p&gt;We assume &lt;code&gt;dnsmasq&lt;/code&gt; will likely accept presentation format for HTTPS resource records in future as &lt;code&gt;bind&lt;/code&gt; tooling already.&lt;/p&gt;

&lt;h2 id=&#34;set-up-nginx-to-serve-an-outer-and-an-inner-hidden-website&#34;&gt;Set up &lt;em&gt;nginx&lt;/em&gt; to serve an outer and an inner (hidden) website&lt;/h2&gt;

&lt;p&gt;Install &lt;em&gt;nginx&lt;/em&gt;-light from the DEfO repo, as above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt install _nginx_-light certbot python3-certbot-_nginx_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t already have a web server config for &lt;code&gt;example.com&lt;/code&gt; then you can create a basic pair of &lt;code&gt;sites-enabled&lt;/code&gt; configuration files via the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# rm /etc/_nginx_/sites-enabled/default
# cp /etc/_nginx_/sites-available/default /etc/_nginx_/sites-enabled/example.conf
# sed -i &#39;s/server_name _;/server_name example.com;/&#39; /etc/_nginx_/sites-enabled/example.conf
# echo &amp;quot;ssl_echkeydir /etc/echkeydir/;&amp;quot; &amp;gt;&amp;gt; /etc/_nginx_/sites-enabled/example.conf
# cp /etc/_nginx_/sites-available/default /etc/_nginx_/sites-enabled/hidden.example.conf
# sed -i -e &#39;s/server_name _;/server_name hidden.example.com;/&#39; -e sed &#39;s/\(listen.*\)default_server;/\1;/&#39; /etc/_nginx_/sites-enabled/hidden.example.conf
# systemctl restart _nginx_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible the &lt;code&gt;sed&lt;/code&gt; commands above may not work for you, e.g. if default files change, or perhaps you won&amp;rsquo;t use those if you have an existing web server config for &lt;code&gt;example.com&lt;/code&gt;&lt;code&gt;. In that case you can simply edit the config files to ensure the following, before running&lt;/code&gt;certbot``:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you have &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;hidden.example.com&lt;/code&gt; servers set up with correct &lt;code&gt;server_name&lt;/code&gt;`&lt;/li&gt;
&lt;li&gt;optionally change the DocRoot (&lt;code&gt;root&lt;/code&gt;) in these configuration files to serve different content&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s a line within the &lt;code&gt;http&lt;/code&gt; stanza as follows:
  &lt;code&gt;ssl_echkeydir /etc/echkeydir/;&lt;/code&gt;`&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;ssl_echkeydir&lt;/code&gt; line can in &lt;code&gt;_nginx_.conf&lt;/code&gt; within the &lt;code&gt;http&lt;/code&gt; stanza or within either of the files in &lt;code&gt;sites-enabled&lt;/code&gt; when it must be outside the &lt;code&gt;server&lt;/code&gt; stanza&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;run-certbot-to-get-a-tls-server-certificate&#34;&gt;Run certbot to get a TLS server certificate&lt;/h2&gt;

&lt;p&gt;Next you need to rRun &lt;code&gt;certbot&lt;/code&gt; to get TLS server public keys certificates for both DNS names (&lt;code&gt;example.com` and `hidden.example.com&lt;/code&gt;). Those can be in the same certificate (or not) for the purposes of this experimental setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# certbot --nginx
...iteractions...
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;certbot&lt;/code&gt; may prompt you for e.g. an email address or approval and if you have an existing certificate for &lt;code&gt;example.com&lt;/code&gt; you may be prompted as to whether you want to add &lt;code&gt;hidden.example.com&lt;/code&gt; to that certificate.&lt;/p&gt;

&lt;h2 id=&#34;use-curl-to-test-the-set-up&#34;&gt;Use &lt;em&gt;curl&lt;/em&gt; to test the set up&lt;/h2&gt;

&lt;p&gt;Install our ECH-enabled &lt;em&gt;curl&lt;/em&gt; package from the DEfO repo and run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -v --ech true --doh-url https://1.1.1.1/dns-query https://hidden.example.com/ |&amp;amp; grep Succeeded
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see this in the output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ECH: result: status is Succeeded, inner is hidden.example.com, outer is example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;check-with-browsers&#34;&gt;Check with browsers&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re running a recent browser version (chromium-based since version 105, firefox since before then:-) you can enable ECH in the browser by &lt;a href=&#34;https://defo.ie/#clients&#34;&gt;following our client configuration instructions&lt;/a&gt;. Unfortunately, browsers don&amp;rsquo;t provide user interface to show if ECH has succeeded or not, but you can verify that your browser is able to use ECH if you visit &lt;a href=&#34;https://defo.ie/ech-check.php&#34;&gt;https://defo.ie/ech-check.php&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;p&gt;All going well, you should now have an ECH-enabled web site and be able to extend/play with that as you like. We&amp;rsquo;d appreciate feedback on this guide if you have a chance. As before, comments/questions are welcome via &lt;a href=&#34;mailto:info@defo.ie&#34;&gt;email&lt;/a&gt; or as GitLab issues/merge requests.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DEfO - Developing ECH for OpenSSL (round two)</title>
      <link>https://guardianproject.github.io/info/2023/11/09/defo-developing-ech-for-openssl-round-two/</link>
      <pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2023/11/09/defo-developing-ech-for-openssl-round-two/</guid>
      <description>

&lt;p&gt;Encrypted ClientHello (ECH) plugs a privacy-hole in TLS, hiding previously visible details from network observers. The most important being the name of the web-site the client wishes to visit (the Server Name Indication or SNI).  This can be a major privacy leak, like when accessing a dissident news source hosted on a Content Delivery Network (&lt;a href=&#34;https://en.wikipedia.org/wiki/Content_delivery_network&#34;&gt;CDN&lt;/a&gt;). A visible domain name also provides a straightforward method for censors to block websites and internet services. &lt;a href=&#34;https://www.tolerantnetworks.com/about-us.html&#34;&gt;Tolerant Networks Limited&lt;/a&gt; and the Guardian Project successfully ran the &lt;a href=&#34;https://www.opentech.fund/&#34;&gt;OTF&lt;/a&gt;-funded &lt;a href=&#34;https://defo.ie/&#34;&gt;DEfO&lt;/a&gt; project that &lt;a href=&#34;https://guardianproject.info/2021/11/30/implementing-tls-encrypted-client-hello/&#34;&gt;developed interoperable implementations&lt;/a&gt; of ECH for OpenSSL, Conscrypt and, via those libraries, a range of ECH-enabled web servers and clients.  This second funded project, DEfO-2, is a timely continuation of that project from the same the team.  As needed for disambiguation, we use DEfO-1 to refer the completed project and DEfO-2 for this current project. When there’s no ambiguity, we use the DEfO acronym to cover both past and future work related to ECH for OpenSSL, related applications and other TLS stacks.&lt;/p&gt;

&lt;p&gt;As the IETF standard for ECH completes, our key objectives are to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Upstream DEfO code&lt;/li&gt;
&lt;li&gt;Integrate ECH into more clients and servers&lt;/li&gt;
&lt;li&gt;Gain and document operational experience&lt;/li&gt;
&lt;li&gt;Submit key code for red team audits&lt;/li&gt;
&lt;li&gt;Publish open-source ECH provisioning tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The key challenges we expect to face in meeting those objectives are: firstly, dealing with the OpenSSL and other upstream code bases (e.g. nginx, Apache HTTP Server) - satisfying upstream developers when dealing with complex code changes, as are involved here, has proven to be quite time and effort consuming. Secondly, it is a challenge to arrange the trials we have envisaged for DEfO-2 but doing so should help to demonstrate that web sites can easily and safely enable ECH without putting themselves at risk of interoperability failures or adverse attention from censors and without further centralising the web. Lastly, there are some remaining technical challenges not addressed in DEfO-1 (proprietary TLS ClientHello extension handling, interactions between TLS Hello Retry Request and ECH, and privacy analyses of split-mode ECH deployments) that we plan to address in DEfO-2.&lt;/p&gt;

&lt;p&gt;The key challenges we aim to mitigate for users is the ease with which user activity can be tracked and blocked based on clear text SNI. Secondarily, our focus on web-server integrations and provisioning mechanisms for ECH addresses Internet centralisation (which itself poses potential risks for censorship) by ensuring this technology can be easily deployed without having to depend on entities such as global-scale CDNs.&lt;/p&gt;

&lt;p&gt;The primary gaps addressed by DEfO are: the privacy-leak that is clear text SNI in TLS and secondly that nobody else has been developing an ECH implementation for OpenSSL, which is one of the most widely used TLS stacks, particularly for web servers. That situation has not changed since DEfO-1 started. Arguably filling that gap has become more pressing as some browsers now ship with ECH support.&lt;/p&gt;

&lt;p&gt;ECH is designed to contribute to the safety of users by removing one the the main remaining aspects of the web that allows network observers to easily monitor and censor web traffic based on either client DNS queries (browsers typically only use ECH when DoH has been used) and the Server Name Indication (SNI) in the TLS handshake, which is encrypted via ECH. The eventual goal is that use of ECH becomes near ubiquitous, and that goal is very achievable for web sites that make use of a CDN. DEfO however also has a focus on ECH support in various web servers and proxies (Apache, nginx, lighttpd, HAProxy) so that users of deployments that don’t use a commercial CDN can also benefit from ECH. The result of using ECH should be that neither the DNS query nor the TLS exchange leak the name of the web server with which the browser is establishing contact, thus taking away a still-easy opportunity for monitoring and censorship.&lt;/p&gt;

&lt;p&gt;Censors however, especially at the nation-state level, might choose to block all uses of ECH, which is something that is to be expected. The main mitigation for that envisaged is that browsers, even while not using ECH, will emit “fake” (or GREASEd) ECH values, thus increasing the costs if a censor decides to block all use of ECH. The extent to which GREASEing will be an effective mitigation for blocking all ECH will essentially
end up as a political/commercial decision for censors, browser makers, and web sites, but what we can say is that for now at least, browser makers and the larger CDNs do seem committed to making use of ECH. So we can have some hope that even the most capable censors might have to think hard before blocking all ECH. In DEfO-2 we are also planning some significant-scale trials that, if successful, should go a long way towards helping other significant web sites overcome fears related to enabling ECH. Overcoming a fear that one’s web site may be blocked if one deploys ECH will be a valuable result of DEfO-2 should our trials come to fruition as we hope.&lt;/p&gt;

&lt;p&gt;We do see a number of usability issues for those deploying web servers that need to be addressed, and that we plan to address in DEfO-2. Our approach is to aim for the same level of usability for web server administrators as has been achieved by &lt;a href=&#34;https://certbot.eff.org/&#34;&gt;&lt;em&gt;certbot&lt;/em&gt;&lt;/a&gt; as it interacts with Let&amp;rsquo;s Encrypt or other CAs. Making it easy to enable ECH, especially for &amp;ldquo;smaller&amp;rdquo; web properties is high priority for DEfO.&lt;/p&gt;

&lt;p&gt;The outcome for which we hope is the upstreaming of ECH into important code bases, and to have demonstrated that one can deploy ECH easily at either small or large scale. The impact we expect is that we continue to significantly contribute to the use of ECH becoming near ubiquitous.&lt;/p&gt;

&lt;h2 id=&#34;timeliness&#34;&gt;Timeliness&lt;/h2&gt;

&lt;p&gt;The time is now ripe for DEfO-2:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://support.mozilla.org/en-US/kb/faq-encrypted-client-hello&#34;&gt;Firefox&lt;/a&gt; now supports ECH by default.&lt;/li&gt;
&lt;li&gt;Chrome supports ECH in &lt;a href=&#34;https://groups.google.com/a/chromium.org/g/blink-dev/c/KrPqrd-pO2M/m/_8Lfd5xcAwAJ&#34;&gt;10% of stable releases&lt;/a&gt; as of August 2023.&lt;/li&gt;
&lt;li&gt;Brave now also supports ECH, &lt;a href=&#34;https://github.com/brave/brave-browser/issues/1851#issuecomment-1763176335&#34;&gt;behind the same flags&lt;/a&gt; as Chromium&lt;/li&gt;
&lt;li&gt;These browser developments, plus the server code developed by DEfO-1, now enable us to plan real-world experiments&lt;/li&gt;
&lt;li&gt;Cloudflare has &lt;a href=&#34;https://developers.cloudflare.com/ssl/edge-certificates/ech/&#34;&gt;beta support&lt;/a&gt; for enabling ECH.&lt;/li&gt;
&lt;li&gt;During the run-time of DEfO-2 we expect to be in a position to run trials with significant players that could significantly assist with the goal of making use of ECH common for large web sites.&lt;/li&gt;
&lt;li&gt;The DEfO-2 project timeline should also cover the finalisation of the IETF specification for ECH, significant progress on ancillary specifications (e.g. for provisioning) and provide sufficient time for upstreaming of DEfO code&lt;/li&gt;
&lt;li&gt;DEfO-2 benefits from the same team as DEfO-1 – Tolerant Networks and the Guardian Project having co-operated successfully on DEfO-1 are looking forward to continuing that collaboration and to extending the team for DEfO-2&lt;/li&gt;
&lt;li&gt;HPKE, a core part of ECH, but with broader applicability, is now RFC9180 and the OpenSSL maintainers merged our DEfO code for HPKE in November 2022.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;our-development-projects&#34;&gt;Our development projects&lt;/h2&gt;

&lt;p&gt;The DEfO project implemented Encrypted ClientHello (ECH) support for OpenSSL and Conscrypt, carried out interoperability testing of those implementations, and also used those libraries to ECH-enable various web servers and clients. We deployed services using these web servers and the DNS infrastructure required to support automated key upated for the HTTPS RRs associated with those services. Here we provide a short overview of that work in order to help with larger scale experiments and with further development of the ECH specification.&lt;/p&gt;

&lt;h3 id=&#34;libraries&#34;&gt;Libraries&lt;/h3&gt;

&lt;p&gt;As part of the DEfO project, we ECH-enabled two important TLS libraries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.conscrypt.org/&#34;&gt;Conscrypt&lt;/a&gt; is a Java Security Provide (a library) that provides a Java &amp;ldquo;wrapper&amp;rdquo; for the C++ language boringssl library. Conscrypt is commonly used as the TLS provider for applications running on Android devices and is thus an attractive target to allow many clients to be ECH-enabled. (We do not target browser clients in DEfO as work on ECH-enabling those is being done by browser-makers.) The authors of boringssl (Google) have added ECH support to a version of their code, and we used that to enhance Conscrypt to call the new borinssl APIs required to use ECH and to provide mechanisms for applications to default to, or signal use of, ECH.&lt;/li&gt;
&lt;li&gt;OpenSSL is a long-lived library providing cryptographic and TLS services that is used by many applications, including many web servers and hence is an attractive target for ECH-enabling, especially for server-side functionality. Our ECH-enabled fork of OpenSSL is here.&lt;/li&gt;
&lt;li&gt;We have and will continue to work with the developers of other TLS libraries (e.g. wolfSSL) to assist in ECH-enabling their code, mostly via interoperability testing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;clients&#34;&gt;Clients&lt;/h3&gt;

&lt;p&gt;We ECH-enabled implemented the following TLS client applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenSSL &lt;code&gt;s_client&lt;/code&gt; - this client application comes as part of the OpenSSL build but is commonly used for testing and as an extremely simple scriptable TLS client.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;curl&lt;/em&gt; is a widely-used command line web client that can use OpenSSL for TLS support, so we &lt;a href=&#34;https://github.com/sftcd/curl/blob/ECH-experimental/docs/ECH.md&#34;&gt;ECH-enabled that&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;F-Droid is an Android client application that provides an installable catalogue of FOSS applications and that uses Conscrypt. We made an ECH-enabled build called &lt;a href=&#34;https://f-droid.org/packages/ie.defo.ech_apps/&#34;&gt;DEfO ECH Apps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;servers&#34;&gt;Servers&lt;/h3&gt;

&lt;p&gt;We ECH-enabled implemented the following web servers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Apache HTTP Server is one of the two most commonly used web servers today, you can try our &lt;a href=&#34;https://github.com/sftcd/httpd&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nginx&lt;/em&gt; is the other web server in the &amp;ldquo;top two.&amp;rdquo;, you can try our &lt;a href=&#34;https://github.com/sftcd/nginx&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;lighttpd is a web server that is commonly used on smaller devices such as home routers, you can try our &lt;a href=&#34;https://github.com/sftcd/lighttpd1.4&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;HAProxy is widely used as an HTTP ingress proxy and so is a good target for exploring ECH split-mode, you can try our &lt;a href=&#34;https://github.com/sftcd/haproxy&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;OpenSSL &lt;code&gt;s_server&lt;/code&gt; - this example server application is part of the OpenSSL build and is commonly used for testing and experimentation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;test-tools&#34;&gt;Test tools&lt;/h3&gt;

&lt;p&gt;Amongst the test tooling we developed are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Comprehensive OpenSSL make test targets for HPKE and ECH.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/defo-project/EchInteropTest&#34;&gt;ECHInteropTest&lt;/a&gt; is a Java client for interoperability testing on Android.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sftcd/echdnsfuzz&#34;&gt;&lt;em&gt;echdnsfuzz&lt;/em&gt;&lt;/a&gt; is a catalogue of &amp;ldquo;interesting&amp;rdquo; ECHConfigList values that could cause issues for clients combined with a service to randomly select one of those for publication in the public DNS every 30 minutes. This is a useful part of fuzz-testing an ECH-enabled client application.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;issues-arising&#34;&gt;Issues Arising&lt;/h2&gt;

&lt;p&gt;We saw the following issues that could benefit from further work to ease deployment of ECH:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For HAProxy, since DEfO-1 we have achieved support for HelloRetryRequest in ECH split-mode but have further work to do on ECH key rotation.&lt;/li&gt;
&lt;li&gt;There can sometimes be a lack of clarity as to which software component should be responsible for choosing to attempt real (i.e. non-GREASEd) ECH, and hence to be responsible for the additional DNS queries required to acquire an ECHConfig. For libraries like OpenSSL and boringssl it clearly only makes sense for that decision (and hence any new DNS handling code) to be outside the library. For a browser, it as clearly makes sense for that code to be in the browser application layer. With &amp;ldquo;middleware&amp;rdquo; though, such as OkHTTP or Conscrypt it can be hard to know which is the correct decision.&lt;/li&gt;
&lt;li&gt;The new DNS code required for handling HTTPS RRs is not too complex but the full generality of SVCB is extremely complex. Adding such complexity (and associated caching) is a major change for clients like curl that have to date only had to have a very simple model for DNS - essentially only querying A/AAAA and having almost trivial caching in the application itself.&lt;/li&gt;
&lt;li&gt;The client implementation of ECH is relatively complex in that it &amp;ldquo;touches&amp;rdquo; the TLS state machine in many ways, and hence requires changes in a lot of places. As well as increasing the cost of implementing this also increases the costs associated with testing and upstreaming.&lt;/li&gt;
&lt;li&gt;Achieving the same level of usability as &lt;code&gt;certbot&lt;/code&gt; for web server administrators may be challenging, but is an important goal to make it easy for web server administrators to be able to easily deploy ECH.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;ECH is demonstrably implementable and can be deployed. We don&amp;rsquo;t yet know if new issues will become apparent as larger-scale experiments are carried out, but we should find out during the run-time of DEfO-2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Improving website resilience with LibResilient and IPFS</title>
      <link>https://guardianproject.github.io/info/2023/06/15/improving-website-resilience-with-libresilient-and-ipfs/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2023/06/15/improving-website-resilience-with-libresilient-and-ipfs/</guid>
      <description>

&lt;p&gt;We&amp;rsquo;re always looking for techniques to make services more resilient to all
sorts of issues. That&amp;rsquo;s why we took special interest in
&lt;a href=&#34;https://resilient.is/&#34;&gt;LibResilient&lt;/a&gt; and mapped out it&amp;rsquo;s capabilities.  It&amp;rsquo;s a
JavaScript library for decentralized content delivery in web-browsers and
markets itself as easy to deploy to any website. We&amp;rsquo;ve looked at LibResilient
primarily in the context of static websites.  While it should work with dynamic
websites too, that was out of focus for us.&lt;/p&gt;

&lt;p&gt;Under the hood LibResilient uses &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&#34;&gt;Web
Workers&lt;/a&gt;.
Technically it&amp;rsquo;s a piece of JavaScript that websites can install into the
browsers of their visitors.  I like to compare it to cookies, except that it&amp;rsquo;s
not just data but actually a program for manipulating your network request. The
main purpose of Web Workers is to enable web apps to optimize their network
connections. Web Workers are pretty low-level API.&lt;/p&gt;

&lt;p&gt;LibResilient delivers implementations for common use-cases on top of Web
Workers in the form of plug-ins.  We&amp;rsquo;ve looked at the 3 most basic of those
plug-ins.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;fetch plugin&lt;/em&gt; - routes network requests directly to the web-server as if
LibResilient wasn&amp;rsquo;t present.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;cache plugin&lt;/em&gt; - stores HTML, JavaScript, images and other files inside
the browsers local storage&lt;/li&gt;
&lt;li&gt;&lt;em&gt;alt-fetch plugin&lt;/em&gt; - allows to configure a list of website mirrors and tries
to fetch files from there&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These enable us to keep a website online and even update it if the main
web-server running that site has an outage.  It&amp;rsquo;s key that visitors must have
managed to load the website at least once before.  Only than can LibResilient
work it&amp;rsquo;s magic and install itself and the list of site mirrors into the users
browser.  This solution doesn&amp;rsquo;t work for first time visitors, during the period
of an outage.&lt;/p&gt;

&lt;p&gt;Of course this requires to run website mirrors. Static websites really shine in
this regard, because they are very easy to mirror and static web-space is quite
inexpensive these days.&lt;/p&gt;

&lt;p&gt;We also looked into using IPFS Gateways as mirrors.  To accomplish this we had
to first add and pin websites to IPFS.  Next we had to publish the pinned copy
of the site to IPNS.  Then we could use the IPNS-key-fingerprint to use every
public IPFS gateway as mirror.  However, public gateways tend to require quite
long to answer requests, which is bad for LibResilient because it uses
relatively short timeouts to fail-over between mirrors.  So to get some sense
of reliability, paid IPFS gateways guaranteed to pin your website are a more
stable choice.&lt;/p&gt;

&lt;h1 id=&#34;publishing-libresilient-to-ipfs&#34;&gt;Publishing LibResilient to IPFS&lt;/h1&gt;

&lt;p&gt;This is a for publishing a static LibResilient enabled website to IPFS.&lt;/p&gt;

&lt;h2 id=&#34;requirements&#34;&gt;requirements&lt;/h2&gt;

&lt;p&gt;You will need VPS, or some other kind of tiny but always online server to make
your data available on IPFS. This guide assumes that your server is running some
flavor of GNU/Linux. It also assumes that you are familiar with the concept of
static websites and that your site is already hosted on the internet.&lt;/p&gt;

&lt;p&gt;Mind that IPFS can be very slow, if you run into timeouts don&amp;rsquo;t give up. Just
wait a few minutes and give it a few more retries, it will work eventually.&lt;/p&gt;

&lt;h2 id=&#34;install-ipfs&#34;&gt;Install IPFS&lt;/h2&gt;

&lt;p&gt;This short snipped will install &lt;code&gt;kubo&lt;/code&gt; the official IPFS binary build on your
server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://dist.ipfs.tech/kubo/v0.18.1/kubo_v0.18.1_linux-amd64.tar.gz
echo &amp;quot;15d42b47b8529edda3e8e2d6fe6c14958d939c4efd07dea02e204743e05216f3 kubo_v0.18.1_linux-amd64.tar.gz&amp;quot; \
    | sha256sum --check
tar -xzf kubo_v0.18.1_linux-amd64.tar.gz
mv kubo/ipfs /usr/local/bin/ipfs
rm -rf kubo kubo_v0.18.1_linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setup kubo daemon to always run in background as systemd service. (Note: this
is tested for Debian and might require different steps on other GNU/Linux
distributions.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adduser ipfs --gecos &#39;&#39; --disabled-password
su ipfs -c &#39;/usr/local/bin/ipfs init --profile server&#39;

cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/systemd/system/ipfs-daemon.service
[Unit]
Description=IPFS Daemon

[Service]
Restart=always
User=ipfs
group=ipfs
WorkingDirectory=/home/ipfs
ExecStart=/usr/local/bin/ipfs daemon

[Install]
WantedBy=default.target
EOF

systemctl enable ipfs-daemon.service
systemctl start ipfs-daemon.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tip: If you&amp;rsquo;re behind a firewall or NAT make sure to open ports 4001/tcp and
4001/udp so IPFS can connect to the internet.&lt;/p&gt;

&lt;h3 id=&#34;publish-site-to-ipfs&#34;&gt;Publish site to IPFS&lt;/h3&gt;

&lt;p&gt;Next we&amp;rsquo;ll publish the website to IPFS. You&amp;rsquo;ll need to copy your static website
to the IPFS server. For this guide we&amp;rsquo;ll assume there&amp;rsquo;s a copy of your website
at &lt;code&gt;/home/ipfs/website&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs add -r /home/ipfs/website&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last line of the output of this command should look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;added QmcoZGQZnaGGdcv3zWf1pdcpMQXuXz74tUy7veWdxCiPck website
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the CID and pin it. Pinning means that your IPFS daemon will never
automatically delete these files to free up memeory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs pin add QmcoZGQZnaGGdcv3zWf1pdcpMQXuXz74tUy7veWdxCiPck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s time to make make it available via IPNS. So we need to generate an
IPNS key. This key will serve as address for accessing the website using IPFS.
It also serves as key for publishing updates to your website.&lt;/p&gt;

&lt;p&gt;NOTE: all commands in this section are to be executed by &lt;code&gt;ipfs&lt;/code&gt; user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs key gen --type=rsa --size=2048 example-site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how you can list your keys:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs key list -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the relevant output should look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;k2k4r8ls72x686fmm2s0px4plejbHkhOm9uuzrxwedsaag1w72ene5rw     example-site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hash of the key, on the left side is going to be the IPNS name of your
website. It&amp;rsquo;s a fixed name that doesn&amp;rsquo;t change even when you update your site.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs name publish --key=example-site QmcoZGQZnaGGdcv3zWf1pdcpMQXuXz74tUy7veWdxCiPck 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When your IPFS node is working and could connect to some peers, your site
should now be accessible using IPNS. Although publishing may take several
minutes. There are so-called &lt;a href=&#34;https://ipfs.github.io/public-gateway-checker/&#34;&gt;public
gateways&lt;/a&gt; which allow users to
access IPFS and IPNS content using http. E.g.:
&lt;a href=&#34;https://cloudflare-ipfs.com/ipns/k51qzi5uqu5dlfqyi5ofzusx23myrrfzxlbzjho4nso0nq28lueo1994l0uwzw&#34;&gt;https://cloudflare-ipfs.com/ipns/k51qzi5uqu5dlfqyi5ofzusx23myrrfzxlbzjho4nso0nq28lueo1994l0uwzw&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can also use &lt;code&gt;ipfs&lt;/code&gt; to check if the files got ingested correctly. E.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs ls /ipns/k51qzi5uqu5dlfqyi5ofzusx23myrrfzxlbzjho4nso0nq28lueo1994l0uwzw
ipfs cat /ipns/k51qzi5uqu5dlfqyi5ofzusx23myrrfzxlbzjho4nso0nq28lueo1994l0uwzw/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update-libresilient-config-to-include-ipns-link&#34;&gt;Update LibResilient config to include IPNS link&lt;/h3&gt;

&lt;p&gt;Now that your site is available on IPNS you can finally add it to your
LibResilient &lt;code&gt;config.json&lt;/code&gt;. You can actually add as many gateways as you&amp;rsquo;d
like with LibResilient&amp;rsquo;s &lt;code&gt;alt-fetch&lt;/code&gt; plugin. Here&amp;rsquo;s a simple example where we
added two gateways:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;plugins&amp;quot;: [{
    &amp;quot;name&amp;quot;: &amp;quot;fetch&amp;quot;
  }, {
    &amp;quot;name&amp;quot;: &amp;quot;alt-fetch&amp;quot;,
    &amp;quot;endpoints&amp;quot;: [
      &amp;quot;https://cloudflare-ipfs.com/ipns/k51qzi5uqu5dlfqyi5ofzusx23myrrfzxlbzjho4nso0nq28lueo1994l0uwzw&amp;quot;,
      &amp;quot;https://ipfs.io/ipns/k51qzi5uqu5dlfqyi5ofzusx23myrrfzxlbzjho4nso0nq28lueo1994l0uwzw&amp;quot;,
    ]
  }],
  &amp;quot;loggedComponents&amp;quot;: [&amp;quot;service-worker&amp;quot;, &amp;quot;fetch&amp;quot;, &amp;quot;alt-fetch&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: We have to use IPNS, because as you can see we need write the IPFS
address to a file which itself is part of the website. With IPNS updating the
site also won&amp;rsquo;t require changing &lt;code&gt;config.json&lt;/code&gt; for every update.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;ve made your pick of IPFS gateways and added them to your
&lt;code&gt;config.json&lt;/code&gt; you can publish it to your web-server.&lt;/p&gt;

&lt;h3 id=&#34;publish-updated-site-to-ipfs&#34;&gt;Publish updated site to IPFS&lt;/h3&gt;

&lt;p&gt;Now you also need to publish the change to IPFS. Again start by copying the
site to your IPFS server. We again assume the updated copy of your static
website is located at &lt;code&gt;/home/ipfs/website&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next we can unpin the old version of the website. (Tip: you can list pinned
files and directories with: &lt;code&gt;ipfs pin ls&lt;/code&gt; pinned directories will be marked as
&lt;code&gt;recursive&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs unpin QmcoZGQZnaGGdcv3zWf1pdcpMQXuXz74tUy7veWdxCiPck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can add the updated site to IPFS and publish it to IPNS again.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ipfs add -r /home/ipfs/website&amp;quot;
ipfs name publish --key=example-site QmcoZrn004DGdRvuZWf1pdcpMQXuXghjCUy7ve5Og45dNU 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can repeat this step whenever you want to publish an updated version of
your static website.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
