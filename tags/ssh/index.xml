<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ssh on Guardian Project</title>
    <link>https://guardianproject.github.io/info/tags/ssh/</link>
    <description>Recent content in Ssh on Guardian Project</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 12 Nov 2013 12:50:23 -0400</lastBuildDate>
    
        <atom:link href="https://guardianproject.github.io/info/tags/ssh/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Your own private dropbox with free software</title>
      <link>https://guardianproject.github.io/info/2013/11/12/your-own-private-dropbox-with-free-software/</link>
      <pubDate>Tue, 12 Nov 2013 12:50:23 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2013/11/12/your-own-private-dropbox-with-free-software/</guid>
      <description>&lt;p&gt;There are lots of file storage and sharing software packages out there that make it easy for a group of people to share files. Dropbox is perhaps the most well known of the group, it provides an easy way for a group of people to share files. The downside of Dropbox is that it is not a private service, just like any cloud-based service. Dropbox has total access to your files that you store there. That means its likely that the NSA and its collaborators do too.&lt;/p&gt;

&lt;p&gt;Dropbox also knows where the computers are that are accessing their service because they can see the IP address of the incoming connections. To help with this, it is possible to use use Dropbox over Tor, thankfully they have provided proxy settings.&lt;/p&gt;

&lt;p&gt;For our shared files, we use &lt;a href=&#34;http://sparkleshare.org/&#34; target=&#34;_blank&#34;&gt;SparkleShare&lt;/a&gt;. It provides an experience very similar to Dropbox: you have a SparkleShare folder that is synced up with the service, and in turn any other users who are also linked up to it. Once its setup, it is as easy to use as Dropbox, but setting it up takes a bit more work than Dropbox. It builds upon two software packages well known for security and reliability: &lt;code&gt;git&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt;, and works with Tor Hidden Services. It runs on Windows, Mac OS X, and GNU/Linux, and there is an &lt;a href=&#34;https://github.com/NewProggie/SparkleShare-Android&#34; target=&#34;_blank&#34;&gt;Android client&lt;/a&gt; in the works.&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2013/11/sparkleshare-onion.png&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2013/11/sparkleshare-onion.png&#34; alt=&#34;sparkleshare-onion&#34; width=&#34;312&#34; height=&#34;342&#34; class=&#34;alignright size-full wp-image-11936&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2013/11/sparkleshare-onion.png 312w, https://guardianproject.info/wp-content/uploads/2013/11/sparkleshare-onion-273x300.png 273w&#34; sizes=&#34;(max-width: 312px) 100vw, 312px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can use any git service as the server for SparkleShare, including github, bitbucket, &lt;a href=&#34;https://gitorious.org/&#34; target=&#34;_blank&#34;&gt;gitorious&lt;/a&gt;, etc. But these have the same issues as putting your files on Dropbox: that service has complete access to your files. For extra protection, SparkleShare &lt;a href=&#34;https://github.com/hbons/SparkleShare/wiki/Client-Side-Encryption&#34; target=&#34;_blank&#34;&gt;can encrypt the files on the client-side&lt;/a&gt;, have encrypted shared folders with SparkleShare, so that the server does not have access to the files. For the last piece of setting up a private SparkleShare, you need a computer that you can &lt;code&gt;ssh&lt;/code&gt; to, and has &lt;code&gt;git&lt;/code&gt; and Tor on it. This computer could even be an old Android device running &lt;a href=&#34;https://guardianproject.info/code/lildebi/&#34; target=&#34;_blank&#34;&gt;Lil’ Debi&lt;/a&gt;, it only needs enough disk space for your SparkleShare files and a steady network connection. Running it on your own computer means it can use a Tor Hidden Service, and that all of the metadata related to who is editing what files remains private.&lt;/p&gt;

&lt;p&gt;To start, setup a Tor Hidden Service to the sshd port. You can read all about that process in the &lt;a href=&#34;https://www.torproject.org/docs/tor-hidden-service.html&#34; target=&#34;_blank&#34;&gt;Tor instructions&lt;/a&gt;, but basically, you need to add something like this to the &lt;code&gt;torrc&lt;/code&gt; configuration file:&lt;/p&gt;

&lt;pre&gt;HiddenServiceDir /var/lib/tor/ssh_hidden_service/
HiddenServicePort 22 127.0.0.1:22
&lt;/pre&gt;

&lt;p&gt;Then restart tor, and it will generate two files in &lt;code&gt;/var/lib/tor/ssh_hidden_service/&lt;/code&gt;, open the file called &lt;code&gt;hostname&lt;/code&gt; to see your new .onion address. We’re going to use &lt;code&gt;fakefakefakefake.onion&lt;/code&gt; as our made-up one for this HOWTO. That is the address you will use in SparkleShare as the server address.&lt;/p&gt;

&lt;p&gt;Next &lt;code&gt;ssh&lt;/code&gt; needs to be setup to use Tor to access the .onion address of the Tor Hidden Service. To do that we need the wonderful Netcat tool (&lt;code&gt;nc&lt;/code&gt;). On Debian/Ubuntu, run &lt;code&gt;sudo apt-get install netcat-openbsd&lt;/code&gt; to get it, its included with Mac OS X by default. Now edit your SSH config file, its usually in &lt;code&gt;~/.ssh/config&lt;/code&gt;, and add this section:&lt;/p&gt;

&lt;pre&gt;Host *.onion
     Compression yes
     ProxyCommand nc -X 5 -x 127.0.0.1:9050 %h %p
&lt;/pre&gt;

&lt;p&gt;For Windows, you need to use &lt;code&gt;connect&lt;/code&gt; proxy, which is thankfully included in SparkleShare. You can optionally use &lt;code&gt;connect&lt;/code&gt; instead of Netcat/&lt;code&gt;nc&lt;/code&gt; on Mac OS X (&lt;code&gt;fink install connect&lt;/code&gt; or &lt;code&gt;brew install connect&lt;/code&gt;) and GNU/Linux (e.g. &lt;code&gt;apt-get install connect-proxy&lt;/code&gt; or &lt;code&gt;yum install connect-proxy&lt;/code&gt;). Instead of the snippet above, use this snippet in &lt;code&gt;~/.ssh/config&lt;/code&gt; to use &lt;code&gt;connect&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;Host *.onion
     Compression yes
     ProxyCommand connect -5 -S 127.0.0.1:9050 %h %p
&lt;/pre&gt;

&lt;p&gt;Now its time to set up the git repo on the server that will be the conduit for sharing files between the different users. Basically, all you need to do is create a new folder, then make it a “bare” git repo (you can read &lt;a href=&#34;http://git-scm.com/book/en/Git-on-the-Server-Setting-Up-the-Server&#34; target=&#34;_blank&#34;&gt;all about it in the git book&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;ssh g&amp;#x69;t&amp;#x40;&amp;#x66;a&amp;#x6b;e&amp;#x66;&amp;#x61;k&amp;#x65;f&amp;#x61;&amp;#x6b;e&amp;#x66;a&amp;#x6b;&amp;#x65;.&amp;#x6f;n&amp;#x69;&amp;#x6f;n
mkdir /home/git/MyPrivateShare
cd /home/git/MyPrivateShare
git init --bare
&lt;/pre&gt;

&lt;p&gt;For sshing to the git, we set up a single account called &lt;code&gt;git&lt;/code&gt;, then to grant access, we add the SSH key (SparkleShare calls this the &lt;em&gt;Client ID&lt;/em&gt;) to the &lt;code&gt;git&lt;/code&gt; account’s &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;Now everything should be ready to start adding clients! In SparkleShare, go to Add Hosted Project…, choose On my own server, then enter your username and .onion address (&lt;em&gt;ssh:&amp;#x2f;&amp;#x2f;&amp;#x67;&amp;#x69;t@fak&amp;#x65;&amp;#x66;&amp;#x61;&amp;#x6b;efake&amp;#x66;&amp;#x61;&amp;#x6b;&amp;#x65;.onio&amp;#x6e;&lt;/em&gt;) in &lt;strong&gt;Address&lt;/strong&gt; and the path to the git repo (&lt;em&gt;/home/git/MyPrivateShare&lt;/em&gt;) in &lt;strong&gt;Remote Path&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2013/11/Screenshot-SparkleShare-Setup.png&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2013/11/Screenshot-SparkleShare-Setup.png&#34; alt=&#34;SparkleShare Setup&#34; width=&#34;686&#34; height=&#34;427&#34; class=&#34;alignnone size-full wp-image-11945&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2013/11/Screenshot-SparkleShare-Setup.png 686w, https://guardianproject.info/wp-content/uploads/2013/11/Screenshot-SparkleShare-Setup-300x186.png 300w&#34; sizes=&#34;(max-width: 686px) 100vw, 686px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now the client will download the entire git repository from the server, and you’ll then have a working shared dropbox! If there are a lot of files in it, then the first sync can take a long time before any files show up. This is because git first downloads the entire history first, then it checks out the files. After that initial setup, then the new files show up quite quickly.&lt;/p&gt;

&lt;p&gt;So this SparkleShare setup keeps your files on computers that you control, it prevents information and metadata from being leaked to the network while people are using this SparkleShare setup. When using Client Side Encryption, even less data is leaked. The server cannot access the content of the files at all since they are encrypted. The the server in this case would only be able to see the network traffic, and which ssh key was used to access the server. If everyone accessing this setup used the same user account (i.e. &lt;code&gt;git&lt;/code&gt;) and ssh key, then the server would not even know which user is making the changes. This is about as private as you could hope for in a shared dropbox folder.&lt;/p&gt;

&lt;p&gt;One last nice feature of this setup is that git server does not need a domain name, static IP or even a public IP, it just needs a working internet connection. As long as it can connect to Tor, then the Hidden Service will work. So if this private dropbox is for extra sensitive stuff, it could be stashed anywhere it can get power and wifi.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Verifying Identity Using Cryptography</title>
      <link>https://guardianproject.github.io/info/2012/03/19/on-verifying-identity-using-cryptography/</link>
      <pubDate>Mon, 19 Mar 2012 11:27:51 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2012/03/19/on-verifying-identity-using-cryptography/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/03/identity.gif&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2012/03/identity-150x150.gif&#34; alt=&#34;&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignleft size-thumbnail wp-image-1684&#34; /&gt;&lt;/a&gt;One of the most important uses of cryptography these days is verifying the identity of the other side of a digital conversation. That conversation could be between two people using OTR-encrypted IM, a web browser showing a bank website, a Debian Developer uploading a package to the Debian build server, an ssh client logging into an ssh server, and on and on. In all of these cases, cryptography is used to ensure that the software is indeed receiving replies from the expected entity. This happens by checking the current cryptographic key against one that is known to be correct. That is essential to the whole process. If you see the key for the first time, you have no way of knowing whether that is indeed the key you are expecting because there is no point of reference.&lt;/p&gt;

&lt;p&gt;In order for this validation of identity to work, there needs to be a method of verifying any given key and making it a reference. There are many ideas about how to do this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a trusted list of central certificate authorities like in HTTPS&lt;/li&gt;
&lt;li&gt;key-signing parties where people validate and sign each other’s keys in person, like used with the OpenPGP Web of Trust&lt;/li&gt;
&lt;li&gt;“trust on first use” (aka “Persistence of Pseudonym”), where you save the key the first time you see it, and then use that as a reference (this is the way most people use SSH)&lt;/li&gt;
&lt;li&gt;fingerprint verification, where the two people wanting to communicate cryptographically use another channel to manually check each other’s key fingerprints, like a phone call (this is used a lot in OTR and OpenPGP)&lt;/li&gt;
&lt;li&gt;the Socialist Millionaires’ Protocol (SMP), which is a combination of user-generated question/answer pairs with a cryptographic technique that lets each side confirm whether the other answered the question correctly without divulging any information (this was recently added to OTR and is implemented in Pidgin, Gibberbot, and maybe a couple other programs)&lt;/li&gt;
&lt;li&gt;a manually confirmed shared secret like a short password (ZRTP uses this when starting secure phone calls)&lt;/li&gt;
&lt;li&gt;whitelists of fingerprints of widely used keys (aka &lt;a href=&#34;http://www.imperialviolet.org/2011/05/04/pinning.html&#34; target=&#34;_blank&#34;&gt;public key pinning&lt;/a&gt;) (this was recently added to Chrome in the wake of the HTTPS certificate authority failures)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/03/fingerprint.jpg&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2012/03/fingerprint-150x150.jpg&#34; alt=&#34;&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignright size-thumbnail wp-image-1686&#34; /&gt;&lt;/a&gt;Each of these techniques has its advantages and disadvantages, but generally the higher level of verification provided means the more work to do the process. Most people don’t need the high level of verification provided by OpenPGP key signing parties, but maybe if it was fun and much easier to do, then a lot more people would do it. “Trust on first use” is really easy to use and implement, and has been working pretty well for a lot of people who use SSH and OTR. But it has big shortcomings in environments where the state or other central authority that provides the internet infrastructure wants to spy on its users. HTTPS has proven to be quite easy to use, but it has also &lt;a href=&#34;https://www.eff.org/deeplinks/2011/08/iranian-man-middle-attack-against-google&#34; target=&#34;_blank&#34;&gt;proven&lt;/a&gt; to be &lt;a href=&#34;http://www.theregister.co.uk/2011/08/29/fraudulent_google_ssl_certificate/&#34; target=&#34;_blank&#34;&gt;quite&lt;/a&gt; &lt;a href=&#34;https://arstechnica.com//security/news/2011/03/how-the-comodo-certificate-fraud-calls-ca-trust-into-question.ars&#34; title=&#34;How the Comodo certificate fraud calls CA trust into question&#34; target=&#34;_blank&#34;&gt;breakable&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Currently, each of these techniques described above is used as the sole means of verification, then the level of verification is represented as “verified” or “not verified”. This is definitely the way that HTTPS and SSH handle it. OTR is a bit different, it has 3 states of verification: “new key”, “unverified key” i.e. trusted on first use, or “verified”, and good OTR chat apps will represent these three states in the UI. Then OpenPGP is perhaps the opposite extreme: it provides both chains of verification signatures via the Web of Trust but also user-set “trust levels” from 0 to 255 for any given key.&lt;/p&gt;

&lt;p&gt;Perhaps an answer is to cryptographically link up these different ways of verification and represent key verification as a continuum. Then when the possibility of linking in “trust on first use” and other techniques was there, people could gradually build up cryptographic trust as they needed it. Starting with “I have seen this key before”, then on to “I have gotten them to verify their OTR key with an SMP question/answer”, then to “I have an OpenPGP trust path to them”, to “I have met them in person and manually verified their key and identity”.&lt;/p&gt;

&lt;p&gt;To go into technical detail as an example, GnuPG supports RSA, DSA, ECDSA, El Gamal, and other key types as subkeys for an OpenPGP key. Those core algorithms core basically all of the most common uses of cryptography, including HTTPS, SSH, OTR, and OpenPGP. The link between an OpenPGP key and its subkeys is perhaps the strongest link for verification that exists, so if a given person includes their OTR key, for example, into their OpenPGP key, that provides a strong cryptographic link between them, and one that is easily publicly sharable via the OpenPGP public keyservers. When two people verify their OTR keys using the SMP question/answer, this verification could then extend to their OpenPGP keys if their OTR keys were subkeys. (&lt;a href=&#34;http://web.monkeysphere.info&#34; target=&#34;_blank&#34;&gt;The Monkeysphere Project&lt;/a&gt; is one such implementation of this idea, using OpenPGP keys for SSH and HTTPS).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/03/verified.jpg&#34;&gt;&lt;img src=&#34;https://guardianproject.info/wp-content/uploads/2012/03/verified-150x150.jpg&#34; alt=&#34;&#34; width=&#34;150&#34; height=&#34;150&#34; class=&#34;alignleft size-thumbnail wp-image-1685&#34; /&gt;&lt;/a&gt;Then the last piece of this puzzle is how to represent all of this complexity to the users. The essential part is to stop representing trust as binary yes/no. A one-dimensional continuum provides a lot more info and is a very commonly understood concept in computers (think progress bars). The hard part of this question is ranking the various techniques in how much progress they provide towards the goal of solid identity verification.&lt;/p&gt;

&lt;p&gt;For this round of the &lt;a href=&#34;https://guardianproject.info/wiki/PSST&#34; title=&#34;Portable Shared Security Tokens&#34; target=&#34;_blank&#34;&gt;PSST Project&lt;/a&gt;, we have focused on first allowing people to easily move around their OTR identities, then worked on testing out the idea of linking in all identity keys into an OpenPGP key. From what we have seen so far, we believe this is not only feasible but will provide a solid platform for linking together all these verification techniques and identity keys. And on top of that, with diligent attention to user experience and testing, it should be possible to create user interfaces that make navigating all of this a common, daily task for most computer users.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
