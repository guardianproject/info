<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tls on Guardian Project</title>
    <link>https://guardianproject.github.io/info/tags/tls/</link>
    <description>Recent content in Tls on Guardian Project</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 10 Jan 2025 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://guardianproject.github.io/info/tags/tls/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using TLS ECH from Python</title>
      <link>https://guardianproject.github.io/info/2025/01/10/using-tls-ech-from-python/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2025/01/10/using-tls-ech-from-python/</guid>
      <description>&lt;p&gt;At first, the idea of encrypting more of the metadata found inside the initial packet (the &amp;ldquo;ClientHello&amp;rdquo;) of a TLS
connection may seem simple and obvious, but there are of course reasons that this wasn&amp;rsquo;t done right from the start.
In this post I will describe the flow of a connection using Encrypted Client Hello (ECH) to protect the metadata fields,
and present a working code example using a fork of CPython built with DEfO project&amp;rsquo;s OpenSSL fork to connect to
ECH-enabled HTTPS servers.&lt;/p&gt;

&lt;p&gt;To understand why this is an issue, let&amp;rsquo;s take a step back and look at how websites are hosted.
Many websites are hosted on shared servers, which means that a single server machine is responsible for serving
multiple, possibly hundreds or thousands, of websites.
This is known as the shared hosting model.
In this setup, when a user types in a URL or clicks on a link to visit a website and the browser connects to the server,
the server needs to know which website the users is requesting.
This is where the Server Name Indication (SNI) comes in - it&amp;rsquo;s a field in the initial packet of a TLS connection that
tells the server which website the user is trying to access.
The server can then send the correct certificate so that the browser can authenticate the connection, and then send the
requested website content.&lt;/p&gt;

&lt;p&gt;Because this field was sent unencrypted, this means that anyone who can see the traffic between the user&amp;rsquo;s browser and
the server can intercept the SNI and know which website the user is trying to visit.
This can be a privacy concern, as it allows ISPs, network administrators, or other unwanted observers to build a profile
of the user&amp;rsquo;s browsing history.
It&amp;rsquo;s not just about the websites they visit, but also about the potential for censorship or targeted attacks.
With the SNI being unencrypted, it&amp;rsquo;s like sending a postcard with the address visible to anyone who handles it - it may
not be the end of the world for most browsing activity, but it&amp;rsquo;s certainly not private.
Encrypted Client Hello aims to change this by encrypting the SNI and other metadata, making it much harder for third
parties to intercept and exploit this information.&lt;/p&gt;

&lt;p&gt;So, why wasn&amp;rsquo;t it easy to protect the SNI and other metadata from the start?
The main challenge was that, in order to encrypt the SNI, the client (i.e., the user&amp;rsquo;s browser) needs to know the
public key that the server wants the ClientHello to be encrypted with in advance.
However, the server&amp;rsquo;s ECH public key is tied to the specific website being requested, and there wasn&amp;rsquo;t a straightforward
way to discover a public key that could be used to talk to the server without revealing the SNI.
This created a chicken-and-egg problem, where the client couldn&amp;rsquo;t encrypt the SNI without knowing the server&amp;rsquo;s public
key, but it couldn&amp;rsquo;t know the server&amp;rsquo;s public key without sending the SNI in plaintext.&lt;/p&gt;

&lt;p&gt;This problem is solved with ECH by introducing a new type of DNS record, called an
&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9460&#34;&gt;HTTPS record&lt;/a&gt;.
An HTTPS record is a special type of DNS record that contains the ECH public key of the server, along with other metadata,
in a way that can be retrieved by the client without revealing the SNI (the website name is still leaked via the DNS
request, but it is possible to protect your requests using DNS-over-TLS or DNS-over-HTTPS).
The HTTPS record is typically retrieved by the client during the DNS lookup process, before the TLS connection is
established.&lt;/p&gt;

&lt;p&gt;The HTTPS record contains an ECH configuration, which is used to encrypt the SNI and other metadata.
This is generated by the server and is tied to the specific configuration of the server, rather than to a specific
website.
By using HTTPS records to retrieve the server&amp;rsquo;s ECH public key, we are able to break the chicken-and-egg problem and
provide a way to encrypt the SNI and other metadata.&lt;/p&gt;

&lt;p&gt;Before we can lookup the HTTPS record, it&amp;rsquo;s first necessary to work out where that record would live.
These records have been designed to be quite flexible, so can accommodate services running on non-default port numbers.
If the default port number is in use then the HTTPS record will be on the same domain name as the website, but for
non-default port numbers, there will be a prefix to the domain name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def svcbname(url: str) -&amp;gt; str:
    &amp;quot;&amp;quot;&amp;quot;Derive DNS name of SVCB/HTTPS record corresponding to target URL.&amp;quot;&amp;quot;&amp;quot;
    parsed = urllib.parse.urlparse(url)
    if parsed.scheme == &amp;quot;https&amp;quot;:
        if (parsed.port or 443) == 443:
            return parsed.hostname
        else:
            return f&amp;quot;_{parsed.port}._https.{parsed.hostname}&amp;quot;
    elif parsed.scheme == &amp;quot;http&amp;quot;:
        if (parsed.port or 80) in (443, 80):
            return parsed.hostname
        else:
            return f&amp;quot;_{parsed.port}._https.{parsed.hostname}&amp;quot;
    else:
        # For now, no other scheme is supported
        return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep it simple, the examples in this post will use plain DNS but the technique is equally applicable to DNS-over-TLS
and DNS-over-HTTPS. Now that we have the domain name to query, we can fetch the ECH configuration from the DNS using
the &lt;a href=&#34;https://www.dnspython.org/&#34;&gt;dnspython&lt;/a&gt; library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_ech_configs(domain) -&amp;gt; List[bytes]:
    try:
        answers = dns.resolver.resolve(domain, &amp;quot;HTTPS&amp;quot;)
    except dns.resolver.NoAnswer:
        logging.warning(f&amp;quot;No HTTPS record found for {domain}&amp;quot;)
        return []
    except Exception as e:
        logging.critical(f&amp;quot;DNS query failed: {e}&amp;quot;)
        sys.exit(1)
    configs: List[bytes] = []
    for rdata in answers:
        if hasattr(rdata, &amp;quot;params&amp;quot;):
            params = rdata.params
            echconfig = params.get(5)
            if echconfig:
                configs.append(echconfig.ech)
    if len(configs) == 0:
        logging.warning(f&amp;quot;No echconfig found in HTTPS record for {domain}&amp;quot;)
    return configs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the ECH configurations are known, these can be used to establish the connection and fetch the website:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_http(url, ech_configs) -&amp;gt; bytes:
    parser = urllib.parse.urlparse(url)
    hostname, port, path = url.hostname, url.port, url.path
    logging.debug(&amp;quot;Performing GET request for https://{hostname}:{port}/{path}&amp;quot;)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.load_verify_locations(certifi.where())
    for config in ech_configs:
        try:
            context.set_ech_config(config)
        except ssl.SSLError as e:
            logging.error(f&amp;quot;SSL error: {e}&amp;quot;)
            pass
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname, do_handshake_on_connect=False) as ssock:
            try:
                ssock.do_handshake()
                logging.debug(&amp;quot;Handshake completed with ECH status: %s&amp;quot;, ssock.get_ech_status().name)
                logging.debug(&amp;quot;Inner SNI: %s, Outer SNI: %s&amp;quot;, ssock.server_hostname, ssock.outer_server_hostname)
                request = f&#39;GET {path} HTTP/1.1\r\nHost: {hostname}\r\nConnection: close\r\n\r\n&#39;
                ssock.sendall(request.encode(&#39;utf-8&#39;))
                response = b&#39;&#39;
                while True:
                    data = ssock.recv(4096)
                    if not data:
                        break
                    response += data
                return response
            except ssl.SSLError as e:
                logging.error(f&amp;quot;SSL error: {e}&amp;quot;)
                raise e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important step here is the new
&lt;a href=&#34;https://irl.github.io/cpython/library/ssl.html#ssl.SSLContext.set_ech_config&#34;&gt;&lt;code&gt;set_ech_config&lt;/code&gt;&lt;/a&gt; method on the
&lt;code&gt;SSLContext&lt;/code&gt; that allows you to add the ECH configuration containing the public key.
If there are multiple records, the underlying OpenSSL will determine which of the keys to use.
There are also a few new methods that allow you to get the status information relating to ECH from the &lt;code&gt;SSLSocket&lt;/code&gt;
after the completion of the handshake.&lt;/p&gt;

&lt;p&gt;In the simple case, that&amp;rsquo;s all there is to it.
If you were to watch the connection with Wireshark you would not be able to see the true SNI being sent to the server
and would only see the decoy SNI present in the unencrypted &amp;ldquo;ClientHelloOuter&amp;rdquo;.
This decoy SNI is added to appease &lt;a href=&#34;https://en.wikipedia.org/wiki/Middlebox&#34;&gt;middleboxes&lt;/a&gt; that may block traffic,
accidentally or deliberately, if that field is missing entirely.
There are also further protections against such middleboxes from the application of GREASE:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the client attempts to connect to a server and does not have an ECHConfig structure available for the server, it
SHOULD send a GREASE &amp;ldquo;encrypted_client_hello&amp;rdquo; extension in the first ClientHello [&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if your client supports ECH but does not have the configuration available to use it, the client should
still send an ECH extension filled with nonsense anyway.
This will help to detect deployment issues early as errors will be immediately obvious to users and won&amp;rsquo;t rely on
servers having deployed ECH before the errors are triggered.&lt;/p&gt;

&lt;p&gt;Finally, if the server sees this GREASE ECH extension then it can use this to know that you support ECH but didn&amp;rsquo;t
have a configuration available.
In its reply, it can send a &amp;ldquo;retry config&amp;rdquo; and then terminate the connection.
You then have the configuration available to start the connection again with a real ECH extension this time, and can
cache that for future requests too.&lt;/p&gt;

&lt;p&gt;For a full client example including the use of retry configs, you can see our
&lt;a href=&#34;https://github.com/defo-project/docker-defo-client/blob/main/pyclient.py&#34;&gt;example Python client&lt;/a&gt; at GitHub.
You&amp;rsquo;ll need to use this with our &lt;a href=&#34;https://github.com/irl/cpython&#34;&gt;CPython fork&lt;/a&gt; and
&lt;a href=&#34;https://github.com/defo-project/openssl&#34;&gt;OpenSSL fork&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick set up guide for Encrypted Client Hello (ECH)</title>
      <link>https://guardianproject.github.io/info/2023/11/10/quick-set-up-guide-for-encrypted-client-hello-ech/</link>
      <pubDate>Fri, 10 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2023/11/10/quick-set-up-guide-for-encrypted-client-hello-ech/</guid>
      <description>

&lt;p&gt;The Encrypted Client Hello (ECH) mechanism &lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-esni&#34;&gt;draft-spec&lt;/a&gt; is a way to plug a few privacy-holes that remain in the Transport Layer Security (TLS) protocol that&amp;rsquo;s used as the security layer for the web. OpenSSL is a widely used library that provides an implementation of the TLS protocol. The &lt;a href=&#34;https://defo.ie/&#34;&gt;DEfO project&lt;/a&gt; has developed an implementation of ECH for OpenSSL, and proof-of-concept implementations of various clients and servers that use OpenSSL, and other TLS libraries, as a demonstration and for interoperability testing. DEfO is funded by the Open Technology Fund (OTF).&lt;/p&gt;

&lt;p&gt;This guide is aimed at those who would like to try out ECH with our experimental Debian &lt;em&gt;unstable&lt;/em&gt; packages for OpenSSL, &lt;em&gt;curl&lt;/em&gt; and &lt;em&gt;nginx&lt;/em&gt;. The DEfO project is making packages temporarily available so people can carry out such experiments before upstream maintainers include ECH in standard releases.&lt;/p&gt;

&lt;p&gt;This guide describes two set ups: one assumes that you want to setup everything (i.e. a web server and associated DNS authoritative server) on one virtual machine and a second describes a way to set up an ECH-enabled web server if you have an existing DNS configuration elsewhere. Many other configurations are of course possible. Comments/questions are welcome via &lt;a href=&#34;mailto:info@defo.ie&#34;&gt;email&lt;/a&gt; or as GitLab issues/merge requests.&lt;/p&gt;

&lt;p&gt;In summary this guide shows how to:
- find and install our Debian &lt;em&gt;unstable&lt;/em&gt; packages
- configure a minimal DNS setup (using dnsmasq or bind) that enables use of ECH from browsers
- configure a minimal &lt;em&gt;nginx&lt;/em&gt; setup for an ECH enabled web sites
- test your DNS set up and that ECH is working&lt;/p&gt;

&lt;p&gt;We assume the reader is comfortable with simple DNS management and system administration tasks.
When commands shown below should be run as &lt;code&gt;root&lt;/code&gt; they are prepended with a &amp;lsquo;#&amp;rsquo;, if not they are prepended with a &amp;lsquo;$&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;install-packages&#34;&gt;Install packages&lt;/h2&gt;

&lt;p&gt;You need to first have access to a virtual machine running Debian &lt;em&gt;unstable&lt;/em&gt;. Many online resources describe many ways to do this.&lt;/p&gt;

&lt;p&gt;We start with an empty (minimal) Debian &lt;em&gt;unstable&lt;/em&gt; system and install OpenSSL from the DEfO apt repository.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt install ca-certificates
# echo &amp;quot;deb [trusted=yes] https://defo.ie/debian/ ./&amp;quot; &amp;gt; /etc/apt/sources.list.d/defo.list
# apt update
# apt install openssl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pick-some-dns-names-to-use&#34;&gt;Pick some DNS names to use&lt;/h2&gt;

&lt;p&gt;In the text below we assume that the web server for which we wish to benefit from ECH is called &lt;code&gt;hidden.example.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ECH also involves a so-called &lt;code&gt;public_name&lt;/code&gt; - that&amp;rsquo;s present in the outer ClientHello when ECH is used and hence is visible to a network observer, unlike the server name we include inside the Encrypted Client Hello. The &lt;code&gt;public_name&lt;/code&gt; we use below is &lt;code&gt;example.com&lt;/code&gt;`&lt;/p&gt;

&lt;p&gt;You should obviously substitute your chosen DNS names.&lt;/p&gt;

&lt;h2 id=&#34;generate-an-ech-key-pair&#34;&gt;Generate an ECH key pair&lt;/h2&gt;

&lt;p&gt;For ECH to work, we need a new asymmetric key pair. (Different from those used for TLS server authentication), so next we generate an ECH key pair:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# mkdir /etc/echkeydir/
# openssl ech -public_name example.com -out /etc/echkeydir/example.pem.ech
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we need this file later to set up DNS as well as &lt;em&gt;nginx&lt;/em&gt;. &lt;em&gt;Nginx&lt;/em&gt; will make use of the private key from the ECH key file, whilst the DNS will be used to publish the corresponding public key in an HTTPS resource record (that&amp;rsquo;s where ECH-enabled browsers will look for ECH public keys).&lt;/p&gt;

&lt;p&gt;The file name chosen should end with &lt;code&gt;.pem.ech&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;set-up-dns&#34;&gt;Set up DNS&lt;/h2&gt;

&lt;p&gt;There are many ways in which one can set up the DNS records required to enable experimenting with ECH. We document two ways here, the first is where the main DNS name with which you&amp;rsquo;re experimenting is newly registered DNS name and has no existing DNS set up. The second describes a case where a DNS name exists but we need to add some new resource records to enable ECH.&lt;/p&gt;

&lt;p&gt;In both cases, &lt;code&gt;&amp;lt;IP&amp;gt;&lt;/code&gt; should be the IPv4 address for the host running the web server. (We leave IPv6 handling as an exercise for the reader, but there&amp;rsquo;s nothing ECH-specific required for IPv6.)&lt;/p&gt;

&lt;h3 id=&#34;standalone-new-setup-dnsmasq-as-a-authoritative-dns-server-to-serve-the-ech-key-on-the-same-vm&#34;&gt;Standalone/New setup : dnsmasq as a authoritative DNS server to serve the ECH key (on the same VM)&lt;/h3&gt;

&lt;p&gt;In this case we also need to pick some DNS nameserver names, we assume the authoritative primary nameserver for both web server DNS names is &lt;code&gt;ns.example.com&lt;/code&gt; with a secondary of &lt;code&gt;ns2.example.com&lt;/code&gt;`&lt;/p&gt;

&lt;p&gt;The DNS set up to use starting from a clean dnsmasq install:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt install dnsmasq
# cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/dnsmasq.d/example.conf
no-resolv
no-hosts
auth-server=ns.example.com,ns2.example.com
auth-zone=example.com
auth-sec-servers=ns2.example.com
auth-soa=42,admin.example.com
host-record=example.com,&amp;lt;IP&amp;gt;
host-record=hidden.example.com,&amp;lt;IP&amp;gt;
dns-rr=hidden.example.com,65,&amp;lt;ascii-hex encoded HTTPS rdata&amp;gt;
EOF
# systemctl restart dnsmasq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you need to bump the SOA version (42 in the above) every time you change the config and make sure the zone distributes to ns2.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;ascii-hex encoded HTTPS rdata&amp;gt;&lt;/code&gt; will be published as the HTTPS resource record (type == 65) for &lt;code&gt;hidden.example.com&lt;/code&gt; and can be produced from the file we generated earlier via a shell script you can download and use as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ _curl_ https://raw.githubusercontent.com/sftcd/openssl/ECH-draft-13c/esnistuff/pem2rr.sh -o pem2rr.sh
$ chmod u+x pem2rr.sh
$ ./pem2rr.sh /etc/echkeydir/example.pem.ech
0001000005003b0039fe0d0035db0020002059907d619054c907a1f296ceb63dde1d57f72f15db172601a2f6b55e66e7cd0f00040001000100066261722e69650000
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;existing-dns-name-setup-using-bind-to-publish-new-ech-related-resource-records&#34;&gt;Existing DNS name setup: using bind to publish new ECH related resource records&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s assume you have an existing bind-based DNS setup for &lt;code&gt;example.com&lt;/code&gt;&lt;code&gt;, but are moving the IP address for that to a new VM that&#39;ll run the ECH-enabled web server for both&lt;/code&gt;example.com&lt;code&gt;and&lt;/code&gt;hidden.example.com`&lt;code&gt;. The change you might then make using the bind&lt;/code&gt;nsupdate` command on the authoritative DNS server would then look like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Change/add IP address records for our DNS names.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bind&#34;&gt;$ sudo nsupdate -l
&amp;gt; update delete example.com a
&amp;gt; update delete example.com aaaa
&amp;gt; update add example.com 300 a &amp;lt;IP&amp;gt;
&amp;gt; update add hidden.example.com 300 a &amp;lt;IP&amp;gt;
&amp;gt; send
&amp;gt; quit
$
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Add new HTTPS resource record for &lt;code&gt;hidden.example.com&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First we need to get the base64 encoded public from our &lt;code&gt;/etc/echkeydir/example.pem.ech&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tail -2 /etc/echkeydir/example.pem.ech | head -1
ADr+DQA2mQAgACAF7cLT+KtK0oR2DrRCGXmzBWM1eHgJgDEGLqL644/OcAAEAAEAAQAHaG9iYS5pZQAA
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That base64 encoded value is what we need to publish in the DNS&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo nsupdate -l
&amp;gt; update delete hidden.example.com HTTPS
&amp;gt; update add hidden.example.com 300 HTTPS 1 . ech=&amp;lt;base64-encoded-value&amp;gt;
&amp;gt; send
&amp;gt; quit
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;checking-your-dns-set-up&#34;&gt;Checking your DNS set up&lt;/h2&gt;

&lt;p&gt;You can check that value is correctly published in the DNS e.g. using the &lt;code&gt;dig command&lt;/code&gt;`:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dig +short https hidden.example.com
1 . ech=ADr+DQA2mQAgACAF7cLT+KtK0oR2DrRCGXmzBWM1eHgJgDEGLqL644/OcAAEAAEAAQAHaG9iYS5pZQAA
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your version of &lt;code&gt;dig&lt;/code&gt; is older and doesn&amp;rsquo;t know about HTTPS resource records, then you may need to check via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dig +short +unknownformat -t TYPE65 hidden.example.com
\# 67 0001000005003C003AFE0D0036990020002005EDC2D3F8AB4AD28476 0EB4421979B30563357878098031062EA2FAE38FCE70000400010001 0007686F62612E69650000
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The 2nd-last invocation of &lt;code&gt;dig&lt;/code&gt; above shows the presentation format version of the HTTPS resource record. The last invocation above shows the equivalent in ascii-hex, which (minus the spaces) is what &lt;code&gt;dnsmasq&lt;/code&gt; needs in it&amp;rsquo;s configuration file.&lt;/p&gt;

&lt;p&gt;We assume &lt;code&gt;dnsmasq&lt;/code&gt; will likely accept presentation format for HTTPS resource records in future as &lt;code&gt;bind&lt;/code&gt; tooling already.&lt;/p&gt;

&lt;h2 id=&#34;set-up-nginx-to-serve-an-outer-and-an-inner-hidden-website&#34;&gt;Set up &lt;em&gt;nginx&lt;/em&gt; to serve an outer and an inner (hidden) website&lt;/h2&gt;

&lt;p&gt;Install &lt;em&gt;nginx&lt;/em&gt;-light from the DEfO repo, as above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt install _nginx_-light certbot python3-certbot-_nginx_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t already have a web server config for &lt;code&gt;example.com&lt;/code&gt; then you can create a basic pair of &lt;code&gt;sites-enabled&lt;/code&gt; configuration files via the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# rm /etc/_nginx_/sites-enabled/default
# cp /etc/_nginx_/sites-available/default /etc/_nginx_/sites-enabled/example.conf
# sed -i &#39;s/server_name _;/server_name example.com;/&#39; /etc/_nginx_/sites-enabled/example.conf
# echo &amp;quot;ssl_echkeydir /etc/echkeydir/;&amp;quot; &amp;gt;&amp;gt; /etc/_nginx_/sites-enabled/example.conf
# cp /etc/_nginx_/sites-available/default /etc/_nginx_/sites-enabled/hidden.example.conf
# sed -i -e &#39;s/server_name _;/server_name hidden.example.com;/&#39; -e sed &#39;s/\(listen.*\)default_server;/\1;/&#39; /etc/_nginx_/sites-enabled/hidden.example.conf
# systemctl restart _nginx_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible the &lt;code&gt;sed&lt;/code&gt; commands above may not work for you, e.g. if default files change, or perhaps you won&amp;rsquo;t use those if you have an existing web server config for &lt;code&gt;example.com&lt;/code&gt;&lt;code&gt;. In that case you can simply edit the config files to ensure the following, before running&lt;/code&gt;certbot``:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you have &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;hidden.example.com&lt;/code&gt; servers set up with correct &lt;code&gt;server_name&lt;/code&gt;`&lt;/li&gt;
&lt;li&gt;optionally change the DocRoot (&lt;code&gt;root&lt;/code&gt;) in these configuration files to serve different content&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s a line within the &lt;code&gt;http&lt;/code&gt; stanza as follows:
  &lt;code&gt;ssl_echkeydir /etc/echkeydir/;&lt;/code&gt;`&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;ssl_echkeydir&lt;/code&gt; line can in &lt;code&gt;_nginx_.conf&lt;/code&gt; within the &lt;code&gt;http&lt;/code&gt; stanza or within either of the files in &lt;code&gt;sites-enabled&lt;/code&gt; when it must be outside the &lt;code&gt;server&lt;/code&gt; stanza&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;run-certbot-to-get-a-tls-server-certificate&#34;&gt;Run certbot to get a TLS server certificate&lt;/h2&gt;

&lt;p&gt;Next you need to rRun &lt;code&gt;certbot&lt;/code&gt; to get TLS server public keys certificates for both DNS names (&lt;code&gt;example.com` and `hidden.example.com&lt;/code&gt;). Those can be in the same certificate (or not) for the purposes of this experimental setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# certbot --nginx
...iteractions...
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;certbot&lt;/code&gt; may prompt you for e.g. an email address or approval and if you have an existing certificate for &lt;code&gt;example.com&lt;/code&gt; you may be prompted as to whether you want to add &lt;code&gt;hidden.example.com&lt;/code&gt; to that certificate.&lt;/p&gt;

&lt;h2 id=&#34;use-curl-to-test-the-set-up&#34;&gt;Use &lt;em&gt;curl&lt;/em&gt; to test the set up&lt;/h2&gt;

&lt;p&gt;Install our ECH-enabled &lt;em&gt;curl&lt;/em&gt; package from the DEfO repo and run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -v --ech true --doh-url https://1.1.1.1/dns-query https://hidden.example.com/ |&amp;amp; grep Succeeded
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see this in the output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ECH: result: status is Succeeded, inner is hidden.example.com, outer is example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;check-with-browsers&#34;&gt;Check with browsers&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re running a recent browser version (chromium-based since version 105, firefox since before then:-) you can enable ECH in the browser by &lt;a href=&#34;https://defo.ie/#clients&#34;&gt;following our client configuration instructions&lt;/a&gt;. Unfortunately, browsers don&amp;rsquo;t provide user interface to show if ECH has succeeded or not, but you can verify that your browser is able to use ECH if you visit &lt;a href=&#34;https://defo.ie/ech-check.php&#34;&gt;https://defo.ie/ech-check.php&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;p&gt;All going well, you should now have an ECH-enabled web site and be able to extend/play with that as you like. We&amp;rsquo;d appreciate feedback on this guide if you have a chance. As before, comments/questions are welcome via &lt;a href=&#34;mailto:info@defo.ie&#34;&gt;email&lt;/a&gt; or as GitLab issues/merge requests.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DEfO - Developing ECH for OpenSSL (round two)</title>
      <link>https://guardianproject.github.io/info/2023/11/09/defo-developing-ech-for-openssl-round-two/</link>
      <pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2023/11/09/defo-developing-ech-for-openssl-round-two/</guid>
      <description>

&lt;p&gt;Encrypted ClientHello (ECH) plugs a privacy-hole in TLS, hiding previously visible details from network observers. The most important being the name of the web-site the client wishes to visit (the Server Name Indication or SNI).  This can be a major privacy leak, like when accessing a dissident news source hosted on a Content Delivery Network (&lt;a href=&#34;https://en.wikipedia.org/wiki/Content_delivery_network&#34;&gt;CDN&lt;/a&gt;). A visible domain name also provides a straightforward method for censors to block websites and internet services. &lt;a href=&#34;https://www.tolerantnetworks.com/about-us.html&#34;&gt;Tolerant Networks Limited&lt;/a&gt; and the Guardian Project successfully ran the &lt;a href=&#34;https://www.opentech.fund/&#34;&gt;OTF&lt;/a&gt;-funded &lt;a href=&#34;https://defo.ie/&#34;&gt;DEfO&lt;/a&gt; project that &lt;a href=&#34;https://guardianproject.info/2021/11/30/implementing-tls-encrypted-client-hello/&#34;&gt;developed interoperable implementations&lt;/a&gt; of ECH for OpenSSL, Conscrypt and, via those libraries, a range of ECH-enabled web servers and clients.  This second funded project, DEfO-2, is a timely continuation of that project from the same the team.  As needed for disambiguation, we use DEfO-1 to refer the completed project and DEfO-2 for this current project. When there’s no ambiguity, we use the DEfO acronym to cover both past and future work related to ECH for OpenSSL, related applications and other TLS stacks.&lt;/p&gt;

&lt;p&gt;As the IETF standard for ECH completes, our key objectives are to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Upstream DEfO code&lt;/li&gt;
&lt;li&gt;Integrate ECH into more clients and servers&lt;/li&gt;
&lt;li&gt;Gain and document operational experience&lt;/li&gt;
&lt;li&gt;Submit key code for red team audits&lt;/li&gt;
&lt;li&gt;Publish open-source ECH provisioning tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The key challenges we expect to face in meeting those objectives are: firstly, dealing with the OpenSSL and other upstream code bases (e.g. nginx, Apache HTTP Server) - satisfying upstream developers when dealing with complex code changes, as are involved here, has proven to be quite time and effort consuming. Secondly, it is a challenge to arrange the trials we have envisaged for DEfO-2 but doing so should help to demonstrate that web sites can easily and safely enable ECH without putting themselves at risk of interoperability failures or adverse attention from censors and without further centralising the web. Lastly, there are some remaining technical challenges not addressed in DEfO-1 (proprietary TLS ClientHello extension handling, interactions between TLS Hello Retry Request and ECH, and privacy analyses of split-mode ECH deployments) that we plan to address in DEfO-2.&lt;/p&gt;

&lt;p&gt;The key challenges we aim to mitigate for users is the ease with which user activity can be tracked and blocked based on clear text SNI. Secondarily, our focus on web-server integrations and provisioning mechanisms for ECH addresses Internet centralisation (which itself poses potential risks for censorship) by ensuring this technology can be easily deployed without having to depend on entities such as global-scale CDNs.&lt;/p&gt;

&lt;p&gt;The primary gaps addressed by DEfO are: the privacy-leak that is clear text SNI in TLS and secondly that nobody else has been developing an ECH implementation for OpenSSL, which is one of the most widely used TLS stacks, particularly for web servers. That situation has not changed since DEfO-1 started. Arguably filling that gap has become more pressing as some browsers now ship with ECH support.&lt;/p&gt;

&lt;p&gt;ECH is designed to contribute to the safety of users by removing one the the main remaining aspects of the web that allows network observers to easily monitor and censor web traffic based on either client DNS queries (browsers typically only use ECH when DoH has been used) and the Server Name Indication (SNI) in the TLS handshake, which is encrypted via ECH. The eventual goal is that use of ECH becomes near ubiquitous, and that goal is very achievable for web sites that make use of a CDN. DEfO however also has a focus on ECH support in various web servers and proxies (Apache, nginx, lighttpd, HAProxy) so that users of deployments that don’t use a commercial CDN can also benefit from ECH. The result of using ECH should be that neither the DNS query nor the TLS exchange leak the name of the web server with which the browser is establishing contact, thus taking away a still-easy opportunity for monitoring and censorship.&lt;/p&gt;

&lt;p&gt;Censors however, especially at the nation-state level, might choose to block all uses of ECH, which is something that is to be expected. The main mitigation for that envisaged is that browsers, even while not using ECH, will emit “fake” (or GREASEd) ECH values, thus increasing the costs if a censor decides to block all use of ECH. The extent to which GREASEing will be an effective mitigation for blocking all ECH will essentially
end up as a political/commercial decision for censors, browser makers, and web sites, but what we can say is that for now at least, browser makers and the larger CDNs do seem committed to making use of ECH. So we can have some hope that even the most capable censors might have to think hard before blocking all ECH. In DEfO-2 we are also planning some significant-scale trials that, if successful, should go a long way towards helping other significant web sites overcome fears related to enabling ECH. Overcoming a fear that one’s web site may be blocked if one deploys ECH will be a valuable result of DEfO-2 should our trials come to fruition as we hope.&lt;/p&gt;

&lt;p&gt;We do see a number of usability issues for those deploying web servers that need to be addressed, and that we plan to address in DEfO-2. Our approach is to aim for the same level of usability for web server administrators as has been achieved by &lt;a href=&#34;https://certbot.eff.org/&#34;&gt;&lt;em&gt;certbot&lt;/em&gt;&lt;/a&gt; as it interacts with Let&amp;rsquo;s Encrypt or other CAs. Making it easy to enable ECH, especially for &amp;ldquo;smaller&amp;rdquo; web properties is high priority for DEfO.&lt;/p&gt;

&lt;p&gt;The outcome for which we hope is the upstreaming of ECH into important code bases, and to have demonstrated that one can deploy ECH easily at either small or large scale. The impact we expect is that we continue to significantly contribute to the use of ECH becoming near ubiquitous.&lt;/p&gt;

&lt;h2 id=&#34;timeliness&#34;&gt;Timeliness&lt;/h2&gt;

&lt;p&gt;The time is now ripe for DEfO-2:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://support.mozilla.org/en-US/kb/faq-encrypted-client-hello&#34;&gt;Firefox&lt;/a&gt; now supports ECH by default.&lt;/li&gt;
&lt;li&gt;Chrome supports ECH in &lt;a href=&#34;https://groups.google.com/a/chromium.org/g/blink-dev/c/KrPqrd-pO2M/m/_8Lfd5xcAwAJ&#34;&gt;10% of stable releases&lt;/a&gt; as of August 2023.&lt;/li&gt;
&lt;li&gt;Brave now also supports ECH, &lt;a href=&#34;https://github.com/brave/brave-browser/issues/1851#issuecomment-1763176335&#34;&gt;behind the same flags&lt;/a&gt; as Chromium&lt;/li&gt;
&lt;li&gt;These browser developments, plus the server code developed by DEfO-1, now enable us to plan real-world experiments&lt;/li&gt;
&lt;li&gt;Cloudflare has &lt;a href=&#34;https://developers.cloudflare.com/ssl/edge-certificates/ech/&#34;&gt;beta support&lt;/a&gt; for enabling ECH.&lt;/li&gt;
&lt;li&gt;During the run-time of DEfO-2 we expect to be in a position to run trials with significant players that could significantly assist with the goal of making use of ECH common for large web sites.&lt;/li&gt;
&lt;li&gt;The DEfO-2 project timeline should also cover the finalisation of the IETF specification for ECH, significant progress on ancillary specifications (e.g. for provisioning) and provide sufficient time for upstreaming of DEfO code&lt;/li&gt;
&lt;li&gt;DEfO-2 benefits from the same team as DEfO-1 – Tolerant Networks and the Guardian Project having co-operated successfully on DEfO-1 are looking forward to continuing that collaboration and to extending the team for DEfO-2&lt;/li&gt;
&lt;li&gt;HPKE, a core part of ECH, but with broader applicability, is now RFC9180 and the OpenSSL maintainers merged our DEfO code for HPKE in November 2022.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;our-development-projects&#34;&gt;Our development projects&lt;/h2&gt;

&lt;p&gt;The DEfO project implemented Encrypted ClientHello (ECH) support for OpenSSL and Conscrypt, carried out interoperability testing of those implementations, and also used those libraries to ECH-enable various web servers and clients. We deployed services using these web servers and the DNS infrastructure required to support automated key upated for the HTTPS RRs associated with those services. Here we provide a short overview of that work in order to help with larger scale experiments and with further development of the ECH specification.&lt;/p&gt;

&lt;h3 id=&#34;libraries&#34;&gt;Libraries&lt;/h3&gt;

&lt;p&gt;As part of the DEfO project, we ECH-enabled two important TLS libraries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.conscrypt.org/&#34;&gt;Conscrypt&lt;/a&gt; is a Java Security Provide (a library) that provides a Java &amp;ldquo;wrapper&amp;rdquo; for the C++ language boringssl library. Conscrypt is commonly used as the TLS provider for applications running on Android devices and is thus an attractive target to allow many clients to be ECH-enabled. (We do not target browser clients in DEfO as work on ECH-enabling those is being done by browser-makers.) The authors of boringssl (Google) have added ECH support to a version of their code, and we used that to enhance Conscrypt to call the new borinssl APIs required to use ECH and to provide mechanisms for applications to default to, or signal use of, ECH.&lt;/li&gt;
&lt;li&gt;OpenSSL is a long-lived library providing cryptographic and TLS services that is used by many applications, including many web servers and hence is an attractive target for ECH-enabling, especially for server-side functionality. Our ECH-enabled fork of OpenSSL is here.&lt;/li&gt;
&lt;li&gt;We have and will continue to work with the developers of other TLS libraries (e.g. wolfSSL) to assist in ECH-enabling their code, mostly via interoperability testing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;clients&#34;&gt;Clients&lt;/h3&gt;

&lt;p&gt;We ECH-enabled implemented the following TLS client applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenSSL &lt;code&gt;s_client&lt;/code&gt; - this client application comes as part of the OpenSSL build but is commonly used for testing and as an extremely simple scriptable TLS client.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;curl&lt;/em&gt; is a widely-used command line web client that can use OpenSSL for TLS support, so we &lt;a href=&#34;https://github.com/sftcd/curl/blob/ECH-experimental/docs/ECH.md&#34;&gt;ECH-enabled that&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;F-Droid is an Android client application that provides an installable catalogue of FOSS applications and that uses Conscrypt. We made an ECH-enabled build called &lt;a href=&#34;https://f-droid.org/packages/ie.defo.ech_apps/&#34;&gt;DEfO ECH Apps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;servers&#34;&gt;Servers&lt;/h3&gt;

&lt;p&gt;We ECH-enabled implemented the following web servers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Apache HTTP Server is one of the two most commonly used web servers today, you can try our &lt;a href=&#34;https://github.com/sftcd/httpd&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nginx&lt;/em&gt; is the other web server in the &amp;ldquo;top two.&amp;rdquo;, you can try our &lt;a href=&#34;https://github.com/sftcd/nginx&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;lighttpd is a web server that is commonly used on smaller devices such as home routers, you can try our &lt;a href=&#34;https://github.com/sftcd/lighttpd1.4&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;HAProxy is widely used as an HTTP ingress proxy and so is a good target for exploring ECH split-mode, you can try our &lt;a href=&#34;https://github.com/sftcd/haproxy&#34;&gt;ECH-enabled fork&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;OpenSSL &lt;code&gt;s_server&lt;/code&gt; - this example server application is part of the OpenSSL build and is commonly used for testing and experimentation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;test-tools&#34;&gt;Test tools&lt;/h3&gt;

&lt;p&gt;Amongst the test tooling we developed are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Comprehensive OpenSSL make test targets for HPKE and ECH.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/defo-project/EchInteropTest&#34;&gt;ECHInteropTest&lt;/a&gt; is a Java client for interoperability testing on Android.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sftcd/echdnsfuzz&#34;&gt;&lt;em&gt;echdnsfuzz&lt;/em&gt;&lt;/a&gt; is a catalogue of &amp;ldquo;interesting&amp;rdquo; ECHConfigList values that could cause issues for clients combined with a service to randomly select one of those for publication in the public DNS every 30 minutes. This is a useful part of fuzz-testing an ECH-enabled client application.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;issues-arising&#34;&gt;Issues Arising&lt;/h2&gt;

&lt;p&gt;We saw the following issues that could benefit from further work to ease deployment of ECH:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For HAProxy, since DEfO-1 we have achieved support for HelloRetryRequest in ECH split-mode but have further work to do on ECH key rotation.&lt;/li&gt;
&lt;li&gt;There can sometimes be a lack of clarity as to which software component should be responsible for choosing to attempt real (i.e. non-GREASEd) ECH, and hence to be responsible for the additional DNS queries required to acquire an ECHConfig. For libraries like OpenSSL and boringssl it clearly only makes sense for that decision (and hence any new DNS handling code) to be outside the library. For a browser, it as clearly makes sense for that code to be in the browser application layer. With &amp;ldquo;middleware&amp;rdquo; though, such as OkHTTP or Conscrypt it can be hard to know which is the correct decision.&lt;/li&gt;
&lt;li&gt;The new DNS code required for handling HTTPS RRs is not too complex but the full generality of SVCB is extremely complex. Adding such complexity (and associated caching) is a major change for clients like curl that have to date only had to have a very simple model for DNS - essentially only querying A/AAAA and having almost trivial caching in the application itself.&lt;/li&gt;
&lt;li&gt;The client implementation of ECH is relatively complex in that it &amp;ldquo;touches&amp;rdquo; the TLS state machine in many ways, and hence requires changes in a lot of places. As well as increasing the cost of implementing this also increases the costs associated with testing and upstreaming.&lt;/li&gt;
&lt;li&gt;Achieving the same level of usability as &lt;code&gt;certbot&lt;/code&gt; for web server administrators may be challenging, but is an important goal to make it easy for web server administrators to be able to easily deploy ECH.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;ECH is demonstrably implementable and can be deployed. We don&amp;rsquo;t yet know if new issues will become apparent as larger-scale experiments are carried out, but we should find out during the run-time of DEfO-2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian over HTTPS</title>
      <link>https://guardianproject.github.io/info/2021/12/08/debian-over-https/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2021/12/08/debian-over-https/</guid>
      <description>

&lt;p&gt;Debian&amp;rsquo;s package manager &lt;a href=&#34;https://wiki.debian.org/SecureApt&#34;&gt;&lt;em&gt;apt&lt;/em&gt;&lt;/a&gt; has a
time-tested method of securely providing packages from the network built on
OpenPGP signatures.  Even though this signing method works well for verifying
the indexes and package files, there are new threats that have become relevant
as man-in-the-middle attacks and data mining become ever easier.  Since 2013,
&lt;em&gt;apt&lt;/em&gt; developers have supported encrypted transport methods HTTPS and Tor Onion
Service.  We have been &lt;a href=&#34;https://guardianproject.github.io/info/2016/07/31/howto-get-all-your-debian-packages-via-tor-onion-services/&#34;&gt;recommending&lt;/a&gt; &lt;a href=&#34;https://guardianproject.github.io/info/2019/01/23/use-onions/https-for-software-updates/&#34;&gt;their&lt;/a&gt; &lt;a href=&#34;https://guardianproject.github.io/info/2014/10/16/reducing-metadata-leakage-from-software-updates/&#34;&gt;use&lt;/a&gt; since &lt;a href=&#34;https://guardianproject.github.io/info/2013/10/31/issues-when-distributing-software/&#34;&gt;2013&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Most major mirrors already support HTTPS, and now &lt;a href=&#34;https://security.debian.org&#34;&gt;https://security.debian.org&lt;/a&gt;
has finally joined the party.  That means it is possible to use HTTPS on all of
the official repositories.  On top of that, many Debian Developers are working
on making &lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=992692&#34;&gt;HTTPS the
default&lt;/a&gt; for new
installs.&lt;/p&gt;

&lt;h2 id=&#34;the-threats&#34;&gt;The threats&lt;/h2&gt;

&lt;p&gt;Now is a good time to reiterate the areas of concern:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Package authenticity (software can be modified while being downloaded).&lt;/li&gt;
&lt;li&gt;Repository availability (whole sites or specific URL paths can be selectively
blocked by the network).&lt;/li&gt;
&lt;li&gt;Package availability (software security updates can be individually blocked).&lt;/li&gt;
&lt;li&gt;Who is downloading what package (currently visible to anyone who can see the
network traffic, including open wifi, etc.).&lt;/li&gt;
&lt;li&gt;Vulnerabilities in &lt;em&gt;apt&lt;/em&gt; or its signature validation (&lt;em&gt;apt&lt;/em&gt; can be
exploited, authenticity checks can be bypassed).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The current &lt;em&gt;apt&lt;/em&gt; model with HTTP covers #1 well, but only covers #2 and #3 with
a one week window (the &lt;code&gt;Valid-Until&lt;/code&gt; header sets the expiration date on the repo
metadata).  That gives attackers a short-term window where blocking and replay
attacks remain effective.  The And it does not cover #4 or #5 at all.&lt;/p&gt;

&lt;p&gt;Using HTTPS adds a weak backup security layer for #1.  HTTPS makes it much more
difficult for certain files from a mirror to be selectively blocked or replayed,
as well as making related errors louder and earlier (e.g. #2 and #3).  Tracking
package downloads needs only simple passive listening with HTTP, but with HTTPS,
the attacker must build full indexes of package sizes, then parse the size from
TLS streams.  So HTTPS helps a little with #4.  Lastly,
&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1829&#34;&gt;there&lt;/a&gt;
&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1358&#34;&gt;have&lt;/a&gt;
&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-3587&#34;&gt;been&lt;/a&gt;
&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-3462&#34;&gt;bugs&lt;/a&gt;
&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1252&#34;&gt;in&lt;/a&gt;
&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0501&#34;&gt;&lt;em&gt;apt&lt;/em&gt;&amp;rsquo;s&lt;/a&gt; GPG
verification.  With HTTP, any network can inject exploits into &lt;em&gt;apt&lt;/em&gt;&amp;rsquo;s
downloads.  HTTPS helps with #5 by providing a backup layer of encryption,
albeit weaker.&lt;/p&gt;

&lt;p&gt;It is of course important to point out that HTTPS itself has flaws, and it is
not the best option out there, especially for protecting anonymity.  HTTPS is
quite easy to use for &lt;em&gt;apt&lt;/em&gt; repositories, so there is hardly any trade-off to
using it.  That is why it is the focus of this post.  If protecting privacy is
important to you, you should use the &lt;a href=&#34;https://onion.debian.org&#34;&gt;Tor Onion Service
repositories&lt;/a&gt;, especially if #4 and #5 concern you.&lt;/p&gt;

&lt;h2 id=&#34;the-risks-of-adding-https&#34;&gt;The risks of adding HTTPS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The only security critique of using HTTPS for repositories that still makes
sense is that there might be vulnerabilities in the code that handles HTTPS,
since its a lot more complicated that HTTP.  In &lt;em&gt;apt&lt;/em&gt;, HTTPS requires GnuTLS,
which is currently linked in by default.  In order to fully protect against
exploits related to the HTTPS code, the machine would need to use a custom build
of &lt;em&gt;apt&lt;/em&gt; with GnuTLS support not included.  It is possible to limit exposure of
the HTTPS implementation by setting &lt;code&gt;Acquire::AllowTLS false&lt;/code&gt;.  This kind of
attack seems to be theoretical as of the time of writing, whereas there are at
least 6 CVEs related to exploiting the GPG verification.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using HTTPS makes using caching proxies much harder to setup.  Caching proxies
can reduce the leakage of metadata about which machine is getting which package,
so using direct HTTPS connections would therefore increase the leakage of that
kind of metadata.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;things-that-can-be-improved&#34;&gt;Things that can be improved&lt;/h2&gt;

&lt;p&gt;There are some additional bits of metadata that can be protected when using
HTTPS, thereby further improving the privacy protections in &lt;em&gt;apt&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;With &lt;a href=&#34;https://www.gnutls.org/manual/gnutls.html#On-Record-Padding&#34;&gt;TLSv1.3 Record
Padding&lt;/a&gt;, TLS
streams &lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1001335&#34;&gt;can be
padded&lt;/a&gt;, which
would obscure the size of the packages being downloaded from network
observers.&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Pipelining downloads through a reused HTTPS connection makes it even more
difficult for the network observer to track packages by size.&lt;/del&gt; Update
2021-12-09: It turns out that &lt;em&gt;apt&lt;/em&gt; is
&lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1001335#10&#34;&gt;already&lt;/a&gt;
&lt;a href=&#34;https://salsa.debian.org/apt-team/apt/commit/895417ef99bb1371d8970da1afe87c6d64382f67&#34;&gt;pipelining&lt;/a&gt;
requests by default, so that can be crossed off the list of things to be
improved.&lt;/li&gt;
&lt;li&gt;The Server Name Indication (SNI) field in TLS will leak the domain name in
plaintext.  The upcoming TLS Encrypted Client Hello standard will encrypt that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The SNI field issue does not exist when using Tor Onion Services.  Package
sizes would still be visible to network observers when using Onion Services, so
TLS padding and pipelining would help there also.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing TLS Encrypted Client Hello</title>
      <link>https://guardianproject.github.io/info/2021/11/30/implementing-tls-encrypted-client-hello/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2021/11/30/implementing-tls-encrypted-client-hello/</guid>
      <description>

&lt;p&gt;As part of the &lt;a href=&#34;https://defo.ie/&#34;&gt;DEfO&lt;/a&gt; project, we have been working on
accelerating the development &lt;a href=&#34;https://www.ietf.org/archive/id/draft-ietf-tls-esni-13.html&#34;&gt;Encrypted Client Hello
(ECH)&lt;/a&gt; as
standardized by the IETF.  ECH is the next step in improving Transport Layer
Security (TLS).  TLS is one of the basic building blocks of the internet, it is
what puts the S in HTTPS.  The ECH standard is nearing completion.  That is
exciting because ECH can encrypt the last plaintext TLS metadata that it is
possible to encrypt.  So ECH will bring some real improvements in privacy and
censorship resistance.&lt;/p&gt;

&lt;p&gt;ECH is built on top of TLSv1.3 and &lt;a href=&#34;https://blog.cloudflare.com/handshake-encryption-endgame-an-ech-update/&#34;&gt;completes unfinished
work&lt;/a&gt;
from the TLSv1.3 effort, now that private DNS is a thing. ECH is now in draft-13
and there are many implementations that are interoperating. ECH is working for
&lt;a href=&#34;https://github.com/sftcd/openssl&#34;&gt;OpenSSL&lt;/a&gt;, &lt;a href=&#34;https://bugs.chromium.org/p/boringssl/issues/detail?id=275&#34;&gt;BoringSSL&lt;/a&gt;, &lt;a href=&#34;https://github.com/sftcd/nginx&#34;&gt;nginx&lt;/a&gt;, &lt;a href=&#34;https://github.com/sftcd/httpd&#34;&gt;Apache HTTPD&lt;/a&gt;, &lt;a href=&#34;https://github.com/sftcd/lighttpd1.4&#34;&gt;lighttpd&lt;/a&gt;,
&lt;a href=&#34;https://github.com/sftcd/haproxy/commits/ECH-experimental&#34;&gt;HAProxy&lt;/a&gt;, &lt;a href=&#34;https://github.com/guardianproject/conscrypt/tree/2.6.alpha1638179154.job1828169525&#34;&gt;Conscrypt&lt;/a&gt;, &lt;a href=&#34;https://github.com/niallor/curl&#34;&gt;curl&lt;/a&gt;, and more. There is work underway in &lt;a href=&#34;https://bugzilla.mozilla.org/show_bug.cgi?id=1725938&#34;&gt;Firefox&lt;/a&gt;
and &lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=1091403&#34;&gt;Chromium&lt;/a&gt;. It has been sketched out for &lt;a href=&#34;https://github.com/square/okhttp/issues/6539&#34;&gt;OkHTTP&lt;/a&gt;. Draft versions of ESNI
and ECH have been deployed in Firefox releases and some production web services.&lt;/p&gt;

&lt;p&gt;The main downside of ECH is that it is
&lt;a href=&#34;https://defo.ie/report.html#issuesarising&#34;&gt;complex&lt;/a&gt;, and most of that is
unavoidable.  Large scale websites have complicated server-side setups, and ECH
has to work in those setups.  That is where ECH&amp;rsquo;s complexity comes from.  &lt;a href=&#34;https://www.ietf.org/archive/id/draft-ietf-dnsop-svcb-https-07.html&#34;&gt;DNS
SVCB and HTTPS RR
Types&lt;/a&gt; is a
related standard to encapsulate the complexity of large scale websites a single
DNS lookup.  It adds additional complexity since it might include the TCP port
number for the service, while TLS implementations mostly assume that the port
number is known before doing a DNS lookup.&lt;/p&gt;

&lt;p&gt;ECH was formerly known as Encrypted SNI (ESNI), which it replaces.  So do not
expect updates to ESNI unless ECH proves too complicated for implementers. ECH
is more complex to implement in the TLS library than ESNI.  Once it is
implemented in the TLS library, then implementing the next level of managing the
keys and hostnames is quite similar between ESNI and ECH.  The rest of this post
will be diving into details about that complexity and what it takes to implement
ECH.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;do-not-stick-out.jpg&#34; alt=&#34;Do Not Stick Out&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;do-not-stick-out&#34;&gt;Do Not Stick Out&lt;/h2&gt;

&lt;p&gt;ECH implementers must also work to ensure that their implementation does not
create packets that look &lt;a href=&#34;https://www.ietf.org/archive/id/draft-ietf-tls-esni-13.html#name-do-not-stick-out&#34;&gt;look
different&lt;/a&gt;
than other implementations.  How ECH is implemented will affect
fingerprintability.  Right now, BoringSSL, OpenSSL, and Firefox all put the ECH
extension in different places, so it is easy for a network observer to tell
which of them is serving as the client in a TLS session.  Ideally, all
implementations would create network packages that look identical to the network
observer.  To get an idea of this problem in the real world, see &lt;a href=&#34;https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/issues/40014&#34;&gt;this detailed
technical
discussion&lt;/a&gt;
of metadata ordering in DTLS as used in WebRTC.&lt;/p&gt;

&lt;h2 id=&#34;getting-the-keys&#34;&gt;Getting the keys&lt;/h2&gt;

&lt;p&gt;ECH encrypts the first stage of the negotiation between the client and server,
the &lt;em&gt;ClientHello&lt;/em&gt; packet using a new type of key and related configuration.
This is known as an &amp;ldquo;ECH Config&amp;rdquo;.  This negotiation is what sets up the
encrypted TLS connection, so to encrypt the negotiation, so the keys can not be
derived from the certificates and negotiation itself.  ECH also needs new
methods distributing this ECH Config.  HTTPS/SVCB therefore includes ECH Config Lists,
and DNS is the recommended way to get ECH Config Lists.  Other distribution
methods are also possible, and ECH implementation should provide a method to
directly supply ECH Config Lists.&lt;/p&gt;

&lt;p&gt;When using ECH in conjunction with HTTPS/SVCB, the DNS needs to be handled differently
than the common, decades old practices that most TLS stacks are built on.  The
ECH Config List must match the IP address so that multi-CDN setups still work.
That ensures the server gets the ECH Config that matches its ECH private keys,
not the one for a separate server.  If the A/AAAA lookup is done separately from
the HTTPS/SVCB lookup, they might not match since the results could come from
different caches, etc.  It is not yet clear where the right place to handle that
DNS is, but it is clear that clients that implement HTTPS/SVCB and ECH will need to
consider that DNS will touch different parts of the stack.&lt;/p&gt;

&lt;p&gt;Which part of the stack will handle the HTTPS/SVCB look up depends on whether
the code is acting as a library or more as the client itself.  For example,
libraries like OkHTTP or Conscrypt can both act as a TLS library, providing the
blocks for implementing TLS in an app.  They can also act as the TLS client
itself, the app just needs to open the hostname and port to get a connection.
This is especially true for OkHTTP, which can also handle DNS itself with its
own DNS-over-HTTPS implementation.  Most apps will expect to just open a URL and
have it work without providing anything else.  In the case of HTTP libraries
like OkHTTP or Volley, Conscrypt becomes the provider of TLS functions rather
than the client.  OkHTTP&amp;rsquo;s default setup will probably want to treat Conscrypt
like the client and do zero config.  But there are use cases where apps want to
handle DNS in OkHTTP, in that case Conscrypt is a library.  Another way this
could be broken down would be to have Conscrypt only be the TLS library, then
leave the DNS to the HTTP stacks.  Then each HTTP library would have to have
their own ECH and HTTPS/SVCB handling (In Android, that would mean
&lt;tt&gt;HttpURLConnection&lt;/tt&gt;, OkHTTP, Volley, Apache HTTP Client, etc).  Python
provides another example with HTTP libraries like &lt;a href=&#34;https://github.com/psf/requests/issues/5972&#34;&gt;Requests&lt;/a&gt; working in
combination with the core &lt;a href=&#34;https://bugs.python.org/issue45567&#34;&gt;&lt;tt&gt;ssl&lt;/tt&gt;&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;One thing that is clear here: whichever piece initiates the HTTPS/SVCB DNS query
should also handle the ECH Config, and setting up the lower levels.  On top of
this, ECH has GREASE and &amp;ldquo;Retry Configs&amp;rdquo;.  GREASE is a key part of ensuring that
ECH connections do not stick out.  GREASE makes the network observer see TLS
packets that look the same as connections that successfully used an ECH Config
to encrypt.  Retry Configs are sent by the server if it cannot decrypt what the
client sent.  Whichever piece of the code handles the ECH Config List should
then also handle GREASE and the Retry Configs.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.cloudflare.com/encrypted-client-hello/&#34;&gt;&lt;img src=&#34;tls-ech-negotiation.png&#34; alt=&#34;TLS ECH Negotiation&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;outer-and-inner-clienthello&#34;&gt;Outer and Inner &lt;em&gt;ClientHello&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;This post began by saying that ECH was complex.  Most of that complexity stems
from the concept of &lt;em&gt;ClientHelloOuter&lt;/em&gt; and &lt;em&gt;ClientHelloInner&lt;/em&gt;.  They are sort of
parallel versions of the TLS &lt;em&gt;ClientHello&lt;/em&gt;, with &lt;em&gt;ClientHelloOuter&lt;/em&gt; being
plaintext and &lt;em&gt;ClientHelloInner&lt;/em&gt; being encrypted.  Many of the same bits of
metadata can be set in either &lt;em&gt;ClientHelloOuter&lt;/em&gt; or &lt;em&gt;ClientHelloInner&lt;/em&gt;, or even
in both.  And the outer and inner values can be different.  For example, the
outer plaintext SNI could be set to a generic domain name, while the inner could
be set to a different domain name that the client wants to protect.  Whenever
the client needs to manage what is set in &amp;ldquo;inner&amp;rdquo;, &amp;ldquo;outer&amp;rdquo;, etc., then extra
complexity is exposed all the way up to the app using the ECH client.  Also, so
many possible configuration options also means so many ways that the negotiation
might fail.&lt;/p&gt;

&lt;p&gt;BoringSSL&amp;rsquo;s &lt;code&gt;SSL_set1_ech_config_list()&lt;/code&gt; provides a good example of this complexity:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a supported ECHConfig is found, &lt;tt&gt;ssl&lt;/tt&gt; will encrypt the true
ClientHello parameters. If the server cannot decrypt it, e.g. due to a key
mismatch, ECH has a recovery flow. &lt;tt&gt;ssl&lt;/tt&gt; will handshake using the
cleartext parameters, including a public name in the ECHConfig. If using
&lt;tt&gt;SSL_CTX_set_custom_verify&lt;/tt&gt;, callers should use
&lt;tt&gt;SSL_get0_ech_name_override&lt;/tt&gt; to verify the certificate with the public
name. If using the built-in verifier, the &lt;tt&gt;X509_STORE_CTX&lt;/tt&gt; will be
configured automatically.&lt;/p&gt;

&lt;p&gt;If no other errors are found in this handshake, it will fail with
&lt;tt&gt;SSL_R_ECH_REJECTED&lt;/tt&gt;. Since it didn&amp;rsquo;t use the true parameters, the
connection cannot be used for application data. Instead, callers should handle
this error by calling &lt;tt&gt;SSL_get0_ech_retry_configs&lt;/tt&gt; and retrying the
connection with updated ECH parameters. If the retry also fails with
&lt;tt&gt;SSL_R_ECH_REJECTED&lt;/tt&gt;, the caller should report a connection failure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-walk-through-which-pieces-needs-to-do-what&#34;&gt;A walk through which pieces needs to do what&lt;/h2&gt;

&lt;p&gt;Let us return to the Python example to go through the pieces needed to implement
ECH there.  Starting at the lowest level, the Python &lt;tt&gt;ssl&lt;/tt&gt; is built on
top of OpenSSL, so the new ECH functions in OpenSSL need to be included and
exposed in &lt;tt&gt;ssl&lt;/tt&gt;&amp;rsquo;s API.  Unlike with a plain TLSv1.3 connection,
&lt;tt&gt;ssl&lt;/tt&gt; would not set up an ECH connection without additional configuration
as long as &lt;tt&gt;ssl&lt;/tt&gt; does not include the additional DNS requirements needed
to fetch the ECH Config.  The DNS could instead be implemented in the HTTP
library.  Requests is built on top of urllib3, so urllib3 could implement
HTTPS/SVCB handling.  Then Requests would automatically get ECH connections.
Since it can be necessary to handle the ECH Config outside of DNS, urllib3 and
Requests could provide methods for the app to submit the ECH Config.  This would
mean overriding any HTTPS/SVCB handling in Requests and urllib3.&lt;/p&gt;

&lt;p&gt;Based on this outline, these are the pieces that need to be implemented:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS/SVCB DNS queries for getting ECH Config Lists, IP, and other config.&lt;/li&gt;
&lt;li&gt;A way to provide ECH Config Lists as bytes directly to the &lt;tt&gt;ssl&lt;/tt&gt; module.&lt;/li&gt;
&lt;li&gt;A method to ensure encrypted DNS is used so all metadata is encrypted.&lt;/li&gt;
&lt;li&gt;A method to enable and disable GREASE, ideally with GREASE default on.&lt;/li&gt;
&lt;li&gt;A callback that gets called whenever ECH negotiation fails and the server
offers a &amp;ldquo;Retry Config&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Potentially also controls of what to send in the &lt;em&gt;ClientHelloOuter&lt;/em&gt; versus the
&lt;em&gt;ClientHelloInner&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the point of view of the client implementation, there is a big difference
between TLS before and after ECH.  This new complexity may look scary but this
is a clear path to providing strong privacy protections with TLS that can be as
widely deployed as TLSv1.3 is now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NetCipher &#43; Conscrypt for the best possible TLS</title>
      <link>https://guardianproject.github.io/info/2019/12/17/netcipher-conscrypt-for-the-best-possible-tls/</link>
      <pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://guardianproject.github.io/info/2019/12/17/netcipher-conscrypt-for-the-best-possible-tls/</guid>
      <description>&lt;p&gt;A new NetCipher library has recently been merged:
&lt;a href=&#34;https://gitlab.com/guardianproject/NetCipher/merge_requests/86&#34;&gt;&lt;em&gt;netcipher-conscrypt&lt;/em&gt;&lt;/a&gt;.
In the same vein as the other NetCipher libraries,
&lt;em&gt;netcipher-conscrypt&lt;/em&gt; wraps the Google
&lt;a href=&#34;https://source.android.com/devices/architecture/modular-system/conscrypt&#34;&gt;Conscrypt&lt;/a&gt;
library, which provides the latest
&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS&lt;/a&gt; for any
app that includes it.  &lt;em&gt;netcipher-conscrypt&lt;/em&gt; lets apps then disable old
TLS versions like TLSv1.0 and TLSv1.1, as well as disable TLS Session
Tickets.  This is an alpha release because it only works on recent
Android versions (8.1 or newer).  The actual functionality works well,
the hard part remains making sure that it is possible to inject
&lt;em&gt;netcipher-conscrypt&lt;/em&gt; as the TLS provider on all Android devices and
versions.  And the last missing piece is finding the right place in
Conscrypt to configure proxying to support Tor or other privacy
proxies&lt;/p&gt;

&lt;p&gt;Before Conscrypt, Android apps relied on the Android OS itself to
provide TLS.  Normally, software uses the TLS provided by the
operating system.  Since too often Android devices do not get software
updates, lots of users are stuck on old TLS versions.  So Google split
out the TLS stack from Android itself and made the Conscrypt library
from it so it can be independently updated.  Guardian Project has been
taking this approach for almost 10 years, starting with
SQLCipher-for-Android and IOCipher libraries.  We are happy to see
Google doing this themselves to give us more platform flexibility and
security.  We plan on using this as a platform for making &lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-sni-encryption&#34;&gt;ESNI
(Encrypted SNI)&lt;/a&gt;
available to all Android apps.&lt;/p&gt;

&lt;p&gt;It is exciting to see ideas that we have been championing over the
past decade to get mainstream adoption.  TLS Session Tickets have
always had serious &lt;a href=&#34;https://blog.filippo.io/we-need-to-talk-about-session-tickets/&#34;&gt;security&lt;/a&gt; and &lt;a href=&#34;https://www.theregister.co.uk/2018/10/19/tls_handshake_privacy/&#34;&gt;privacy&lt;/a&gt; issues, Android 10 &lt;a href=&#34;https://source.android.com/devices/architecture/modular-system/conscrypt#consrypt-q&#34;&gt;now
provides&lt;/a&gt;
an official API for disabling TLS Session Tickets:
&lt;a href=&#34;https://developer.android.com/reference/android/net/ssl/SSLSockets.html&#34;&gt;android.net.ssl.SSLSockets&lt;/a&gt;
and
&lt;a href=&#34;https://developer.android.com/reference/android/net/ssl/SSLEngines.html&#34;&gt;android.net.ssl.SSLEngines&lt;/a&gt;.
And the idea of per-app file encryption, which &lt;em&gt;IOCipher&lt;/em&gt; provides, can
now be largely provided by the built-in &lt;a href=&#34;https://source.android.com/security/encryption/file-based&#34;&gt;Android File-Based Encryption
(FBE)&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tweaking HTTPS for Better Security</title>
      <link>https://guardianproject.github.io/info/2014/02/12/tweaking-https-for-better-security/</link>
      <pubDate>Wed, 12 Feb 2014 19:14:59 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2014/02/12/tweaking-https-for-better-security/</guid>
      <description>&lt;p&gt;The HTTPS protocol is based on TLS and SSL, which are standard ways to negotiate encrypted connections. There is a lot of complexity in the protocols and lots of config options, but luckily most of the config options can be ignored since the defaults are fine. But there are some things worth tweaking to ensure that as many connections as possible are using reliable encryption ciphers while providing &lt;a href=&#34;https://en.wikipedia.org/wiki/Forward_secrecy&#34;&gt;forward secrecy&lt;/a&gt;. A connection with forward secrecy provides protection to past transactions even if the server’s HTTPS private key/certificate is stolen or compromised. This protects your users from large scale network observers that can store all traffic for later decryption, like governments, ISPs, telecoms, etc. From the server operator’s point of view, it means less risk of leaking users’ data, since even if the server is compromised, past network traffic will probably not be able to be encrypted.&lt;/p&gt;

&lt;p&gt;In my situation, I was using our development site, &lt;a href=&#34;https://dev.guardianproject.info&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://dev.guardianproject.info&#34;&gt;https://dev.guardianproject.info&lt;/a&gt;&lt;/a&gt;, as my test bed, it is Apache 2.2 and openssl 1.0.1 running on Ubuntu/precise 12.04 Long-Term Support, so that means that some of the options are more limited since this is an older release. On Debian, Ubuntu and other Debian-derivatives, you’ll only need to edit &lt;code&gt;/etc/apache2/mods-available/ssl.conf&lt;/code&gt;. There are more paranoid resources &lt;a href=&#34;https://community.qualys.com/blogs/securitylabs/2013/08/05/configuring-apache-nginx-and-openssl-for-forward-secrecy&#34; target=&#34;_blank&#34;&gt;for perfectly configuring your TLS&lt;/a&gt;, but we’re not ready to drop support for old browsers that only support SSLv3, and not TLS at all. So I went with this line to enable SSLv3 and TLSv1.0 and newer:&lt;br /&gt;
&lt;code&gt;&amp;lt;br /&amp;gt;
SSLProtocol all -SSLv2&amp;lt;br /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With TLS connections, the client and the server each present a list of encryption ciphers that represent the ciphers they each support in order of preference. This enables the client and server to choose a cipher that both support. Normally, the client’s list takes precedence over the server’s, but with many browsers that can be changed. Unfortunately it seems that Microsoft Internet Explorer (IE) ignores this and always uses the client’s preference first. Here’s how to make Apache request that the server preferences are preferred:&lt;br /&gt;
&lt;code&gt;&amp;lt;br /&amp;gt;
SSLHonorCipherOrder on&amp;lt;br /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Next up is tweaking the server’s preference list to put ciphers that enable forward secrecy first (don’t worry if you don’t understand the next stuff about my rationale, my aim is to walk thru the process). This is done in most web servers using openssl-style cipher lists. I started out with &lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS&#34; target=&#34;_blank&#34;&gt;what Mozilla recommends&lt;/a&gt;, then pared down the list to remove AES-256 ciphers, since AES-128 is widely regarded to be faster, quite strong, and perhaps &lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS#Prioritization_logic&#34; target=&#34;_blank&#34;&gt;more resistant to timing attacks than AES-256&lt;/a&gt;. I also chose to remove RC4-based ciphers, since &lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS#RC4_weaknesses&#34; target=&#34;_blank&#34;&gt;RC4 might already be broken&lt;/a&gt;, and will only get worse with time. RC4 has historically been used to mitigate the “BEAST” attack, but that is &lt;a href=&#34;https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&#34; target=&#34;_blank&#34;&gt;mostly happening in the clients now&lt;/a&gt;. So with that I ended up with this cipher list (should be all one line in your config file):&lt;br /&gt;
&lt;code&gt;&amp;lt;br /&amp;gt;
SSLCipherSuite &amp;quot;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-CAMELLIA128-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:CAMELLIA128-SHA:DES-CBC3-SHA&amp;quot;&amp;lt;br /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;One thing to make sure is that all of these ciphers are supported on your system. You can get the list of supported ciphers from &lt;code&gt;openssl ciphers&lt;/code&gt;. I used this command line to get them in a nice, alphabetized list:&lt;br /&gt;
&lt;code&gt;&amp;lt;br /&amp;gt;
openssl ciphers | sed &#39;s,:,\n,g&#39; | sort&amp;lt;br /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lastly, we want to set the &lt;a href=&#34;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&#34; target=&#34;_blank&#34;&gt;HSTS&lt;/a&gt; header to tell the browser to always use HTTPS. To enforce this, a header is added to the collection of HTTP headers delivered when connecting to the HTTPS site. This header tells the client browser to always connect to the current domain using HTTPS. It includes an expiration date (aka &lt;code&gt;max-age&lt;/code&gt;) after which, the client browser will again allow HTTP connections to that domain. The server might then again redirect the HTTP connection to HTTPS, and again the client will get the HSTS header, and use only HTTPS until the expiration date comes again. To include this header in your Apache server, add this line:&lt;br /&gt;
&lt;code&gt;&amp;lt;br /&amp;gt;
Header add Strict-Transport-Security &amp;quot;max-age=15768000;includeSubDomains&amp;quot;&amp;lt;br /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now you can check the results of your work with Qualys’ handy SSL Test. You can see the result of my efforts here: &lt;a href=&#34;https://www.ssllabs.com/ssltest/analyze.html?d=dev.guardianproject.info&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://www.ssllabs.com/ssltest/analyze.html?d=dev.guardianproject.info&#34;&gt;https://www.ssllabs.com/ssltest/analyze.html?d=dev.guardianproject.info&lt;/a&gt;&lt;/a&gt;. &lt;strong&gt;A-&lt;/strong&gt; is not bad. I tried for a good long while to get IE to use FS (Forward Secrecy) ciphers, but failed. IE does not respect the server-side cipher preferences. My guess is that the only way to get IE to use FS ciphers is to make a custom cipher list that does not include anything but FS ciphers and serve that only to IE. I know it is possible to do because &lt;a href=&#34;https://www.ssllabs.com/ssltest/analyze.html?d=bitbucket.com&amp;s=131.103.20.172&#34; target=&#34;_blank&#34;&gt;bitbucket.com got an &lt;strong&gt;A+&lt;/strong&gt; for doing it&lt;/a&gt;. For a quick way to check out the cipher lists and HSTS header, look at &lt;a href=&#34;https://github.com/iSECPartners/sslyze&#34; target=&#34;_blank&#34;&gt;iSEC Partner’s sslyze&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is only a quick overview of the process to outline the general concepts. To find out more I recommend reading the source articles for this post, including specific directions for nginx and lighttpd:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mozilla’s &lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS&#34; target=&#34;_blank&#34;&gt;Server-side TLS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qualys’ &lt;a href=&#34;https://community.qualys.com/blogs/securitylabs/2013/08/05/configuring-apache-nginx-and-openssl-for-forward-secrecy&#34; target=&#34;_blank&#34;&gt;Configuring Apache, Nginx, and OpenSSL for Forward Secrecy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qualys’ &lt;a href=&#34;https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&#34; target=&#34;_blank&#34;&gt;Is BEAST Still a Threat?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&#34; target=&#34;_blank&#34;&gt;HTTP Strict Transport Security&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>VoIP security architecture in brief</title>
      <link>https://guardianproject.github.io/info/2013/11/21/voip-security-architecture-in-brief/</link>
      <pubDate>Thu, 21 Nov 2013 19:07:17 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2013/11/21/voip-security-architecture-in-brief/</guid>
      <description>&lt;p&gt;Voice over IP (VoIP) has been around for a long time. It’s ubiquitous in homes, data centers and carrier networks. Despite this ubiquity, security is rarely a priority. With the combination of a handful of important standard protocols, it is possible to make untappable end to end encryption for an established VoIP call.&lt;/p&gt;

&lt;p&gt;TLS is the security protocol between the signaling endpoints of the session. It’s the same technology that exists for SSL web sites; ecommerce, secure webmail, Tor and many others use TLS for security. Unlike web sites, VoIP uses a different protocol called the Session Initiation Protocol (SIP) for signaling: actions like ringing an endpoint, answering a call and hanging up. This is the metadata of calls. SIP-TLS uses the standard Certificate Authorities for key agreement. This implies trust between the certificate issuer and the calling endpoints.&lt;/p&gt;

&lt;div id=&#34;attachment_12006&#34; style=&#34;width: 440px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;http://www.siptutorial.net/SIP/relation.htm&#34;&gt;&lt;img aria-describedby=&#34;caption-attachment-12006&#34; src=&#34;https://guardianproject.info/wp-content/uploads/2013/11/relation.gif&#34; alt=&#34;SIP Dialog&#34; width=&#34;430&#34; height=&#34;322&#34; class=&#34;size-full wp-image-12006&#34; /&gt;&lt;/a&gt;
  
  &lt;p id=&#34;caption-attachment-12006&#34; class=&#34;wp-caption-text&#34;&gt;
    An example of a SIP dialog
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;To add a little complexity, the content of calls has only a small relationship to SIP. The key agreement protocol for P2P VoIP content is called ZRTP. In a true P2P system, all the key agreement and encryption of a call’s content happens in the endpoint applications. An important distinction between VoIP and other networked communications is that all devices are both client and server at once, so we have only “endpoints” rather than “clients” or “servers”. Once the endpoints agree on a shared secret, the ZRTP session ends and the SRTP session begins. When established, all audio and video content going over the network is encrypted. Only the two peer endpoints who established a session with ZRTP can decrypt the media stream. This is the part of the conversation that cannot be wiretapped nor can metadata of sessions in progress be spied on.&lt;/p&gt;

&lt;div id=&#34;attachment_12008&#34; style=&#34;width: 560px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2013/11/zrtp_overview.png&#34;&gt;&lt;img aria-describedby=&#34;caption-attachment-12008&#34; src=&#34;https://guardianproject.info/wp-content/uploads/2013/11/zrtp_overview-902x1024.png&#34; alt=&#34;ZRTP Overview&#34; width=&#34;550&#34; height=&#34;624&#34; class=&#34;size-large wp-image-12008&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2013/11/zrtp_overview-902x1024.png 902w, https://guardianproject.info/wp-content/uploads/2013/11/zrtp_overview-264x300.png 264w, https://guardianproject.info/wp-content/uploads/2013/11/zrtp_overview.png 986w&#34; sizes=&#34;(max-width: 550px) 100vw, 550px&#34; /&gt;&lt;/a&gt;
  
  &lt;p id=&#34;caption-attachment-12008&#34; class=&#34;wp-caption-text&#34;&gt;
    An example ZRTP key exchange
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;To step back a little, let’s review some acronyms. First there is &lt;a href=&#34;http://www.siptutorial.net/SIP/background.html&#34;&gt;SIP&lt;/a&gt; (Session Initialization Protocol). This protocol is encrypted with TLS. It contains the IP addresses of the endpoints who wish to communicate but it does not interact with the audio or video stream.&lt;/p&gt;

&lt;p&gt;Second, there is ZRTP. This protocol enters into the mix after a successful SIP dialog establishes a call session by locating the two endpoints. It transmits key agreement information over a unverified SRTP channel between the peers. The peers use their voices to speak a secret that verifies that the channel is secure between only the two peers.&lt;/p&gt;

&lt;p&gt;Third, enter SRTP. Only after the ZRTP key exchange succeeds is the call content encrypted with the Secure Real Time Protocol. From this point forward, all audio and video is secure and uniquely keyed to each individual session.&lt;/p&gt;

&lt;p&gt;This brief was inspired by the numerous discussions I’ve participated in online and offline during my ongoing operation of ostel.co, a secure VoIP service sponsored by The Guardian Project. I understand that VoIP is complex when compared to HTTP and the mainstream understanding of the securirty elements often omits the ZRTP/SRTP content, rather focusing on only the SIP-TLS signaling. While signaling is important, few calls would be useful without content.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Proposal for Secure Connection Notification on Android</title>
      <link>https://guardianproject.github.io/info/2012/11/15/proposal-for-secure-connection-notification-on-android/</link>
      <pubDate>Thu, 15 Nov 2012 10:07:49 -0400</pubDate>
      
      <guid>https://guardianproject.github.io/info/2012/11/15/proposal-for-secure-connection-notification-on-android/</guid>
      <description>&lt;p&gt;A major problem of mobile applications being increasingly used over web-based applications, is that there is no standard established for notifying the user of the state of security on the network connection. With a web browser, the evolution of the “lock” icon when an &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Secure&#34;&gt;HTTPS connection&lt;/a&gt; is made, has been one that evolved originally out of Netscape’s first implementation, to an adhoc, defact industry-standard way of letting the user know if their connection is secure. Beyond just a binary on/off, the lock icon is also the entry point into viewing more information about the digital security tokens, keys and certificates that are powering the connection – who authorized them, who requested them, and so on. More recently, with browsers such as Chrome, there has been the user of color schemes (Green is good, Red is bad), verified domain display and other indicators to help ensure the user knows when to trust their connection, and when to be wary.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/11/Firefox_3_rc1_Extended_Validation_SSL_address_bar_and_certificate_detail.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-2952&#34; title=&#34;Firefox_3_rc1_Extended_Validation_SSL_address_bar_and_certificate_detail&#34; src=&#34;https://guardianproject.info/wp-content/uploads/2012/11/Firefox_3_rc1_Extended_Validation_SSL_address_bar_and_certificate_detail-300x182.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;182&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2012/11/Firefox_3_rc1_Extended_Validation_SSL_address_bar_and_certificate_detail-300x182.png 300w, https://guardianproject.info/wp-content/uploads/2012/11/Firefox_3_rc1_Extended_Validation_SSL_address_bar_and_certificate_detail.png 429w&#34; sizes=&#34;(max-width: 300px) 100vw, 300px&#34; /&gt;&lt;br /&gt;
&lt;/a&gt; &lt;em&gt;Firefox’s HTTPS certificate display&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;While many people claim that HTTPS/TLS/SSL are fundamentally broken, they are still an essential piece of basic frontline security on the web. In addition, when making a connection through a proxy network like Tor or a free VPN service, utilizing TLS/SSL is critical in making sure you network is not being intercepted along the way. The notification icon and related certificate viewing, is a critical component for the user, and one that is entirely missing in the mobile application space. The Android API does not provide a standardized method to share this information with the user, and the implementation on iOS is unclear, as well. Even worse, the proper implementation of a strong HTTP/S connection that properly handles verification of certificates, and provides an interactive option for users to accept or decline is entirely missing for the majority of mobile apps.&lt;/p&gt;

&lt;p&gt;With that in mind, we have added a Secure Connection Notification feature into our new &lt;a href=&#34;https://github.com/guardianproject/OnionKit&#34;&gt;OnionKit for Android&lt;/a&gt; library. Build upon our previous work on &lt;a href=&#34;https://github.com/guardianproject/cacert&#34;&gt;implementing custom Root CA Certificate stores for Android&lt;/a&gt;, this library not only provides a clear way to enable HTTP and SOCKS proxying for your network requests (to enable use with our app, &lt;a href=&#34;https://guardianproject.info/apps/orbot/&#34;&gt;Orbot: Tor for Android&lt;/a&gt;), but it also includes a &lt;a href=&#34;https://github.com/guardianproject/OnionKit/blob/master/library/src/info/guardianproject/onionkit/trust/StrongTrustManager.java&#34;&gt;StrongTrustManager&lt;/a&gt; and a &lt;a href=&#34;https://github.com/guardianproject/OnionKit/blob/master/library/src/info/guardianproject/onionkit/trust/StrongHttpsClient.java&#34;&gt;StrongHTTPSClient&lt;/a&gt; implementation, that works to defend against man-in-the-middle attacks, and other means to intercept a TLS or SSL connection between a mobile app and a remote server. Part of the defense, is providing a clear indicator to the user when a secure connection is in use.&lt;/p&gt;

&lt;p&gt;We have provided a &lt;a href=&#34;https://github.com/guardianproject/OnionKit/blob/master/sample/src/sample/onionkit/OnionKitSampleActivity.java&#34;&gt;sample Android app&lt;/a&gt; to demonstrate how simple it is to enable this capability. The screenshots below are from that app.&lt;/p&gt;

&lt;p&gt;In this first screenshot, the app has connected to &lt;a href=&#34;https://check.torproject.org&#34;&gt;https://check.torproject.org&lt;/a&gt; and you can see in the Notification bar a “key” icon indicating there is a secure connection active.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/11/noTor.png&#34;&gt;&lt;img class=&#34;size-medium wp-image-2947 alignnone&#34; title=&#34;noTor&#34; src=&#34;https://guardianproject.info/wp-content/uploads/2012/11/noTor-254x300.png&#34; alt=&#34;&#34; width=&#34;254&#34; height=&#34;300&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2012/11/noTor-254x300.png 254w, https://guardianproject.info/wp-content/uploads/2012/11/noTor.png 800w&#34; sizes=&#34;(max-width: 254px) 100vw, 254px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When you drag the notification bar down, you can see a more complete view of the Secure Connection Notification (SCN) message, which indicates the connection is Active and shows a summary of the secure certificate information. In a recent update to the OnionKit SCN code, it also allows for the application to include its name and icon in this notification.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-204130.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-2948&#34; title=&#34;device-2012-11-08-204130&#34; src=&#34;https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-204130-300x139.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;139&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-204130-300x139.png 300w, https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-204130.png 800w&#34; sizes=&#34;(max-width: 300px) 100vw, 300px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally, you can tap on the SCN notification and bring up a larger pop-over view of the certificate information. We intend to develop this view further, to allow for better manual management of trust – meaning you may have the option to accept/decline or disable trust of this certificate or the certificate authority that provides it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-203216.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-2949&#34; title=&#34;device-2012-11-08-203216&#34; src=&#34;https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-203216-300x222.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;222&#34; srcset=&#34;https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-203216-300x222.png 300w, https://guardianproject.info/wp-content/uploads/2012/11/device-2012-11-08-203216.png 800w&#34; sizes=&#34;(max-width: 300px) 100vw, 300px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Beyond “Active” messages, the notification system will also warn or block connections that are deemed risky, invalid or otherwise unverifiable. You can use OnionKit in concert with the &lt;a href=&#34;https://github.com/ge0rg/MemorizingTrustManager&#34;&gt;MemorizingTrustManager&lt;/a&gt; to manually override this verification process, if your application is expected to often connect to servers with unverifiable certificates. Finally, using our &lt;a href=&#34;https://github.com/guardianproject/cacert&#34;&gt;CACert project&lt;/a&gt;, you can generate custom Root CA stores for use with OnionKit, that utilize your own certificate authorities, or a custom rolled set.&lt;/p&gt;

&lt;p&gt;Our goal is not to overwhelm the user, but instead to provide them a simple notification so they can understand which applications have their best interests in mind, and which do not. It is amazing how many popular mobile apps transmit personal information using HTTP completely in plain text, in the clear, allowing any number of parties along the network path between the device and server to passively vacuum up this data. Users generally are not aware or do not care about this issue. It is up to the mobile application developer, to adopt an approach like our Secure Connection Notification, or to directly utilize our OnionKit library itself.&lt;/p&gt;

&lt;p&gt;Finally, we would like to see Android and other mobile operating systems, adopt a system such as this device-wide, such that it becomes as standard as the desktop web browser HTTPS lock.&lt;/p&gt;

&lt;p&gt;If you are a developer, please check out OnionKit for Android today, and let us know what you think: &lt;a href=&#34;https://github.com/guardianproject/OnionKit/&#34;&gt;https://github.com/guardianproject/OnionKit/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
